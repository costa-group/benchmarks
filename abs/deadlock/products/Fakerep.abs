module ReplicationSystem.Environment.Files;

export *;

import * from ABS.Scheduler;
import * from ReplicationSystem.Environment.DataTypes;
import * from ABS.StdLib;

type TransactionHistories = List<Transaction>;

type Transaction = Pair<TransactionId, Map<FileId, FileContent>>;

data JobData = JobData(String jschedname, Int waitperiod, Int jdeadline, Int jcost, Int beforetime, Int deadlineafter, Int totaltime, Int jobid);

def Maybe<JobData> updateJobData(Maybe<JobData> jd, Int cost, Int currentDeadline, Time current) = 
  case jd {
    Just( JobData( a, b, c, d, e, f, g, h ) ) => Just( JobData( a, b, c, cost, e, currentDeadline, abs(( timeValue(current) - g )), h ) );
  };

type TestData = Map<TransactionId, Map<FileId, FileContent>>;

type FileId = String;

type FileSize = Int;

type File = Pair<FileId, FileContent>;

type Directory = Pair<FileId, FileContent>;

type ReplicationItem = Pair<TransactionId, Set<File>>;

type FileEntry = Map<FileId, FileContent>;

def Set<File> entryToFiles(FileEntry entry) = 
  entryToFiles2(getFileIdFromEntries1(entry), entry);

def Set<File> entryToFiles2(Set<FileId> ids, FileEntry entry) = 
  case ids {
    EmptySet => EmptySet;
    Insert( id, ss ) => Insert( Pair( id, fromJust(getFromEntry(entry, id)) ), entryToFiles2(ss, entry) );
  };

def Set<Pair<A, B>> entrySet<A, B>(Map<A, B> m) = 
  case m {
    EmptyMap => EmptySet;
    InsertAssoc( x, xs ) => Insert( x, entrySet(xs) );
  };

def Pair<FileId, FileContent> qualifyEntry(Pair<FileId, FileContent> e, FileId path) = 
  case isDirectory(snd(e)) {
    True => right(fromJust(qualify(Just( Right( e ) ), path)));
    False => left(fromJust(qualify(Just( Left( e ) ), path)));
  };

def Map<FileId, FileContent> qualifyFileEntry(Map<FileId, FileContent> m, FileId path) = 
  case m {
    EmptyMap => EmptyMap;
    InsertAssoc( x, xs ) => InsertAssoc( qualifyEntry(x, path), qualifyFileEntry(xs, path) );
  };

def Map<String, Schedule> schedulemap(Schedules ss) = 
  case ss {
    EmptySet => EmptyMap;
    Insert( x, xs ) => case x {
      NoSchedule => schedulemap(xs);
      _ => InsertAssoc( Pair( schedname(x), x ), schedulemap(xs) );
    };
  };

data Schedule = Schedule(String schedname, List<Item> items, Int sched, Deadline dline)| NoSchedule;

data Item = SearchItem(FileId)| FileItem(FileId, String)| LogItem(FileId);

def Bool isSearchItem(Item s) = 
  case s {
    SearchItem( _ ) => True;
    _ => False;
  };

def Bool isFileItem(Item s) = 
  case s {
    FileItem( _, _ ) => True;
    _ => False;
  };

def Bool isLogItem(Item s) = 
  case s {
    LogItem( _ ) => True;
    _ => False;
  };

def Maybe<Schedule> getSchedule(List<Schedule> ss, String n) = 
  case ss {
    Nil => Nothing;
    Cons( x, xs ) => case ( schedname(x) == n ) {
      True => Just( x );
      False => getSchedule(xs, n);
    };
  };

def List<Schedule> itemMapToSchedule(List<Schedule> ss, Map<String, Pair<Int, Deadline>> ts, List<Pair<String, List<Item>>> im) = 
  case im {
    Nil => ss;
    Cons( Pair( x, y ), xs ) => let ( Maybe<Schedule> s ) = getSchedule(ss, x) in case s {
      Just( k ) => itemMapToSchedule(Cons( Schedule( schedname(k), concatenate(y, items(k)), sched(k), dline(k) ), without(ss, k) ), removeKey(ts, x), xs);
      Nothing => let ( Pair<Int, Deadline> p ) = lookupUnsafe(ts, x) in itemMapToSchedule(Cons( Schedule( x, y, fst(p), snd(p) ), ss ), removeKey(ts, x), xs);
    };
  };

def Schedules insertReplicationItemsTo(Schedules ss, String name, List<Item> items) = 
  case ss {
    EmptySet => EmptySet;
    Insert( x, xs ) => case ( schedname(x) == name ) {
      True => Insert( insertReplicationItems(x, items), xs );
      False => Insert( x, insertReplicationItemsTo(xs, name, items) );
    };
  };

def Schedule insertReplicationItems(Schedule s, List<Item> items) = 
  case s {
    Schedule( n, ll, d, e ) => Schedule( n, concatenate(ll, items), d, e );
  };

def Set<Item> scheduleItems(Schedules ss) = 
  case ss {
    EmptySet => EmptySet;
    Insert( x, xs ) => union(listToSet(items(x)), scheduleItems(xs));
  };

def Either<FileId, Pair<FileId, String>> item(Item s) = 
  case s {
    SearchItem( i ) => Left( i );
    FileItem( i, r ) => Right( Pair( i, r ) );
    LogItem( i ) => Left( i );
  };

type Schedules = Set<Schedule>;

data FileContent = Content(FileSize content)| Entries(FileEntry entries)| NoContent;

def Bool isAncester(FileId id1, FileId id2) = 
  isPrefix(deroot(split(id2, fileSep())), deroot(split(id1, fileSep())));

def List<String> deroot(List<String> path) = 
  let ( FileId r ) = rootId() in case path {
    Cons( r, ps ) => ps;
    _ => path;
  };

def File file(FileId i, FileSize s) = 
  Pair( i, Content( s ) );

def Directory rootDir() = 
  emptyDir(rootId());

def Directory emptyDir(FileId i) = 
  Pair( i, Entries( EmptyMap ) );

def Directory dir(FileId i, FileEntry e) = 
  Pair( i, Entries( e ) );

def String fileSep() = 
  "/";

def FileId rootId() = 
  "root";

def Bool isFile(FileContent c) = 
  case c {
    Content( _ ) => True;
    _ => False;
  };

def Bool isDirectory(FileContent c) = 
  ~ isFile(c);

def FileSize fileContent(File f) = 
  content(snd(f));

def FileEntry dirContent(Directory f) = 
  entries(snd(f));

def FileId getFileId(Either<File, Directory> f) = 
  case f {
    Left( Pair( id, _ ) ) => id;
    Right( Pair( id, _ ) ) => id;
  };

def FileContent getFileContent(Either<File, Directory> f) = 
  case f {
    Left( Pair( _, s ) ) => s;
    Right( Pair( _, fs ) ) => fs;
  };

def Either<File, Directory> makeContent(Pair<FileId, FileContent> content) = 
  case isFile(snd(content)) {
    True => Left( content );
    False => Right( content );
  };

def FileId makePath(FileId dir, FileId f) = 
  ( ( dir + fileSep() ) + f );

def FileId makePaths(List<String> fs) = 
  case fs {
    Nil => "";
    Cons( f, Nil ) => f;
    Cons( f, gs ) => ( ( f + fileSep() ) + makePaths(gs) );
  };

def Pair<FileId, FileId> splitFileId(FileId f) = 
  Pair( dirName(f), fileName(f) );

def FileId fileName(FileId f) = 
  head(reverse(split(f, fileSep())));

def FileId dirName(FileId f) = 
  makePaths(reverse(tail(reverse(split(f, fileSep())))));

def Set<FileId> getFileIdFromDir(Directory d) = 
  case snd(d) {
    Entries( e ) => case ( fst(d) == rootId() ) {
      True => getFileIdFromEntries1(e);
      False => getFileIdFromEntries(fst(d), e);
    };
  };

def Set<FileId> getFileIdFromEntries1(FileEntry fe) = 
  case fe {
    EmptyMap => EmptySet;
    InsertAssoc( Pair( i, c ), fs ) => case isFile(c) {
      True => Insert( i, getFileIdFromEntries1(fs) );
      False => union(getFileIdFromEntries(i, entries(c)), getFileIdFromEntries1(fs));
    };
  };

def Set<FileId> getFileIdFromEntries(FileId id, FileEntry fe) = 
  case fe {
    EmptyMap => EmptySet;
    InsertAssoc( Pair( i, c ), fs ) => case isFile(c) {
      True => Insert( makePath(id, i), getFileIdFromEntries(id, fs) );
      False => union(getFileIdFromEntries(makePath(id, i), entries(c)), getFileIdFromEntries(id, fs));
    };
  };

def Bool hasEntriesIn(Directory d, FileId id) = 
  case snd(d) {
    Entries( e ) => hasEntry(e, id);
  };

def Bool hasEntry(FileEntry f, FileId id) = 
  isJust(findFromEntry(f, id));

def Maybe<Either<File, Directory>> findFromEntryIn(Directory d, FileId id) = 
  case snd(d) {
    Entries( e ) => findFromEntry(e, id);
  };

def Maybe<Either<File, Directory>> findFromEntry(FileEntry f, FileId id) = 
  case contains(keys(f), id) {
    True => case lookupUnsafe(f, id) {
      Content( s ) => makeMaybeEitherValue(True, id, Content( s ));
      Entries( e ) => makeMaybeEitherValue(False, id, Entries( e ));
    };
    False => case f {
      InsertAssoc( Pair( i, Content( _ ) ), fm ) => findFromEntry(fm, id);
      InsertAssoc( Pair( i, Entries( g ) ), fm ) => case findFromEntry(g, id) {
        Nothing => findFromEntry(fm, id);
        r => qualify(r, i);
      };
      EmptyMap => Nothing;
    };
  };

def Maybe<Either<File, Directory>> qualify(Maybe<Either<File, Directory>> r, FileId path) = 
  case r {
    Just( h ) => let ( FileId hi ) = makePath(path, getFileId(h)) in let ( FileContent hc ) = getFileContent(h) in case h {
      Left( _ ) => makeMaybeEitherValue(True, hi, hc);
      Right( _ ) => makeMaybeEitherValue(False, hi, hc);
    };
    Nothing => Nothing;
  };

def Maybe<Either<File, Directory>> makeMaybeEitherValue(Bool isfile, FileId id, FileContent c) = 
  case isfile {
    True => Just( Left( Pair( id, c ) ) );
    _ => Just( Right( Pair( id, c ) ) );
  };

def Bool hasQualifiedEntriesIn(Directory d, FileId qualified) = 
  case snd(d) {
    Entries( e ) => hasQualifiedEntry(e, qualified);
  };

def Bool hasQualifiedEntry(FileEntry f, FileId qualified) = 
  isJust(getFromEntry(f, qualified));

def Maybe<FileContent> getFromEntryIn(Directory d, FileId qualified) = 
  case snd(d) {
    Entries( e ) => case ( fst(d) == rootId() ) {
      True => getFromEntry(e, qualified);
      _ => getFromEntry(InsertAssoc( d, EmptyMap ), qualified);
    };
  };

def Maybe<FileContent> getFromEntry(FileEntry entry, FileId qualified) = 
  let ( List<String> paths ) = split(qualified, fileSep()) in case ( length(paths) > 0 ) {
    True => case contains(keys(entry), head(paths)) {
      True => let ( FileContent cc ) = lookupUnsafe(entry, head(paths)) in case length(tail(paths)) {
        0 => Just( cc );
        _ => case cc {
          Content( _ ) => Nothing;
          Entries( e ) => getFromEntry(e, makePaths(tail(paths)));
        };
      };
      False => Nothing;
    };
    False => Nothing;
  };

def Directory updateDirWithContent(Directory d, FileId i, FileContent c) = 
  updateDirWith(d, makeContent(Pair( i, c )));

def Directory updateDirWithContents(Directory d, Map<FileId, FileContent> contents) = 
  case contents {
    EmptyMap => d;
    InsertAssoc( Pair( i, c ), cs ) => updateDirWithContents(updateDirWithContent(d, i, c), cs);
  };

def Directory updateDirWithFile(Directory d, File f) = 
  updateDirWith(d, Left( f ));

def Directory updateDirWithDir(Directory d, Directory f) = 
  updateDirWith(d, Right( f ));

[( d >= 0 )] [( f >= 0 )] [( result() >= 0 )] [( result() <= ( ( d + ( 2 * f ) ) + 1 ) )]
def Directory updateDirWith(Directory d, Either<File, Directory> f) = 
  case snd(d) {
    Entries( e ) => Pair( fst(d), Entries( updateFile(e, f) ) );
  };

def FileEntry updateFile(FileEntry fe, Either<File, Directory> f) = 
  updateFile1(fe, getFileContent(f), deroot(split(getFileId(f), fileSep())));

def FileEntry updateFile1(FileEntry fe, FileContent c, List<String> path) = 
  case path {
    Nil => fe;
    Cons( p, Nil ) => put(fe, p, c);
    Cons( p, ps ) => case contains(keys(fe), p) {
      True => case lookupUnsafe(fe, p) {
        Entries( dc ) => put(fe, p, Entries( updateFile1(dc, c, ps) ));
        _ => put(fe, p, create(ps, c));
      };
      False => put(fe, p, create(ps, c));
    };
  };

def FileContent create(List<String> path, FileContent c) = 
  case path {
    Cons( p, Nil ) => Entries( InsertAssoc( Pair( p, c ), EmptyMap ) );
    Cons( p, ps ) => Entries( InsertAssoc( Pair( p, create(ps, c) ), EmptyMap ) );
  };

def Directory applyChanges(Directory d, TransactionHistories th, TransactionId id) = 
  case th {
    Nil => d;
    Cons( x, xs ) => case ( fst(x) <= id ) {
      True => applyChanges(updateDirWithContents(d, snd(x)), xs, id);
      False => d;
    };
  };






























module ReplicationSystem.Server;

export *;

import * from ReplicationSystem.Environment.Files;
import * from ReplicationSystem.Environment.DataTypes;
import * from ReplicationSystem.Environment.ReplicationSnapshot.Interfaces;
import * from ReplicationSystem.Server.Interfaces;
import * from ReplicationSystem.Environment.ReplicationSnapshot.Interfaces;
import * from ReplicationSystem.Environment.Interfaces;
import * from ReplicationSystem.Server.SyncServerAcceptor;
import * from ReplicationSystem.Server.SyncServerClientCoordinator;
import * from ReplicationSystem.Environment.DataBases;
import * from ReplicationSystem.Server.ReplicationSnapshot;
import * from ABS.StdLib;

[COG]
class SyncServerImpl(Schedules schedules, Set<ClientId> clients) implements SyncServer {
  Bool shutDown = False;
  [Far]
  SyncServerClientCoordinator coordinator;
  [Near]
  UpdatableDataBase db;
  [Near]
  ReplicationSnapshot snapshot;
  Map<String, Schedule> scheduleMap = schedulemap(schedules);
  {
    db = new local DataBaseImpl();
    snapshot = new local ReplicationSnapshotImpl(db, schedules);
  }
  
  Unit run(){
    coordinator = new SyncServerClientCoordinatorImpl(clients);
    Fut<Unit> f = coordinator!setSnapshot(snapshot);
    f.get;
  }
  DataBase getDataBase(){
    return db;
  }
  Schedule getSchedule(String name){
    assert contains(keys(scheduleMap), name);
    return lookupUnsafe(scheduleMap, name);
  }
  Schedules listSchedules(){
    return schedules;
  }
  ReplicationSnapshot getReplicationSnapshot(){
    return snapshot;
  }
  UpdatableDataBase getUpdatableDataBase(){
    return db;
  }
  Bool isShutdownRequested(){
    return shutDown;
  }
  Unit requestShutDown(){
    shutDown = True;
  }
  SyncServerClientCoordinator getCoordinator(){
    [this]
    await ( coordinator != null );
    return coordinator;
  }
  }


module ReplicationSystem.Interfaces;

export *;

import * from ReplicationSystem.Environment.Interfaces;
import * from ReplicationSystem.Environment.Files;
import * from ReplicationSystem.Environment.DataTypes;
import * from ABS.StdLib;

interface Tester {
  Unit analyse();}


module ReplicationSystem.Client;

export *;

import * from ABS.DC;
import * from ABS.Scheduler;
import * from ReplicationSystem.Environment.DataTypes;
import * from ReplicationSystem.Environment.Files;
import * from ReplicationSystem.Environment.StateMachine;
import * from ReplicationSystem.Client.Interfaces;
import * from ReplicationSystem.Interfaces;
import * from ReplicationSystem.Server.Interfaces;
import * from ReplicationSystem.Environment.Interfaces;
import * from ReplicationSystem.Environment.DataBases;
import * from ReplicationSystem.Client.ClientJob;
import * from Replication.Network;
import * from ReplicationSystem.Schedulers;
import * from ReplicationSystem.ReplicationSystem;
import * from ABS.StdLib;

[COG] [Scheduler : edf(queue)]
class SyncClientImpl([Final]Int maxJobs, [Final]ClientId id, [Final]ReplicationSystem sys) implements InternalClient, ClientConnector {
  StateMachine machine = stateMachine();
  State state = Start;
  Network network;
  ServerAcceptor acceptor;
  ClientDataBase db;
  Bool shutDown = False;
  Bool next = False;
  List<Schedule> hit = Nil;
  List<Schedule> missed = Nil;
  Int jobRecords = 0;
  Int jobHistories = 0;
  Int currentTransactionId = - 1;
  {
    db = new local DataBaseImpl();
  }
  
  [Atomic]
  Int jobCount(){
    return jobHistories;
  }
  Unit scheduleJob(ClientJob job, JobType jb, Schedule schedule){
    this.waitFor(job, schedule);
    if ( ~ shutDown ){
      this.setNext(schedule);
      this.makeJob(jb, schedule);
      hit = Cons( schedule, hit );
    } else {
      missed = Cons( schedule, missed );
    }
  }
  Unit setNext(Schedule schedule){
    next = False;
  }
  Unit waitFor(ClientJob job, Schedule schedule){
    [job]
    await ( next || shutDown );
  }
  Unit makeJob(JobType jb, Schedule schedule){
    ClientJob job = new ClientJobImpl(maxJobs, this, jb, schedule, jobHistories);
    job!executeJob();
    jobHistories = ( jobHistories + 1 );
    jobRecords = ( jobRecords + 1 );
  }
  Unit finishJob(){
    jobRecords = ( jobRecords - 1 );
  }
  Unit nextJob(){
    if ( ( jobHistories >= maxJobs ) ){
      this.requestShutDown();
    } else {
      next = True;
    }
  }
  ClientId getId(){
    return id;
  }
  Bool isShutdownRequested(){
    return shutDown;
  }
  Unit requestShutDown(){
    shutDown = True;
    [this]
    await ( jobRecords == 0 );
    network!shutDown(this);
  }
  ServerAcceptor getAcceptor(){
    return acceptor;
  }
  Unit run(){
    this.becomesState(WaitToBoot);
    [sys]
    await ( acceptor != null );
    this.makeJob(Boot, NoSchedule);
  }
  ClientDataBase getClientDataBase(){
    return db;
  }
  DataBase getDataBase(){
    return db;
  }
  Unit becomesState(State state){
    Set<State> tos = lookupDefault(machine, state, EmptySet);
    assert ( tos != EmptySet );
    assert contains(tos, state);
    state = state;
  }
  Unit setAcceptor([Far]ServerAcceptor acc){
    acceptor = acc;
  }
  Unit setNetwork(Network network){
    this.network = network;
  }
  Unit waitToBoot(){
    this.becomesState(WaitToBoot);
  }
  Unit boot(){
    this.becomesState(Booting);
  }
  Unit start(){
    this.becomesState(Booting);
  }
  Unit waitToReplicate(){
    this.becomesState(WaitToReplicate);
  }
  Unit replicate(){
    this.becomesState(WorkOnReplicate);
  }
  Unit end(){
    this.becomesState(End);
  }
  }


module ReplicationSystem.Environment.ReplicationSnapshot.Interfaces;

export *;

import * from ReplicationSystem.Environment.Files;
import * from ReplicationSystem.Environment.DataTypes;
import * from ABS.StdLib;

interface ReplicationSnapshot {
  [Atomic]
  Unit refreshSnapshot();
  Unit clearSnapshot();
  Int getIndexingId();
  Set<ServerReplicationItem> getItems(String name);}

interface ServerReplicationItem {
  Command getCommand();
  ReplicationItemType getType();
  [Atomic]
  Unit refresh();
  FileEntry getContents();
  [Atomic]
  Unit cleanup();
  FileId getAbsoluteDir();}


module Replication.Network;

export *;

import * from ReplicationSystem.Client.Interfaces;
import * from ReplicationSystem.Server.Interfaces;
import * from ReplicationSystem.Environment.Interfaces;
import * from ReplicationSystem.Tests;
import * from ReplicationSystem.Environment.Files;
import * from ABS.StdLib;

interface Network {
  Unit shutDown(ClientConnector client);
  Bool powerDown();
  Unit shutDownUpdater();}

class Network(SyncServer server, Int clients) implements Network {
  Bool powerDown = False;
  List<ClientDataBase> databases = Nil;
  
  Unit shutDown(ClientConnector client){
    Fut<ClientDataBase> df = client!getClientDataBase();
    ClientDataBase db = df.get;
    databases = Cons( db, databases );
    if ( ( length(databases) == clients ) ){
      powerDown = True;
    }
  }
  Bool powerDown(){
    return powerDown;
  }
  Unit shutDownUpdater(){
    assert ( powerDown == True );
    Fut<Unit> ss = server!requestShutDown();
    ss.get;
    while (( length(databases) > 0 )) {
      Tester tester = new TesterImpl(server, head(databases));
      tester!analyse();
      databases = tail(databases);
    }
  }
  }


module ReplicationSystem.Server.ConnectionThread;

export ConnectionThreadImpl;

import * from ReplicationSystem.Environment.Files;
import * from ReplicationSystem.Environment.DataTypes;
import * from ReplicationSystem.Environment.ReplicationSnapshot.Interfaces;
import * from ReplicationSystem.Client.Interfaces;
import * from ReplicationSystem.Server.Interfaces;
import * from ReplicationSystem.Schedulers;
import * from ReplicationSystem.Server.SyncServerAcceptor;
import * from ABS.StdLib;

[COG]
class ConnectionThreadImpl([Far]ClientJob job, [Far]SyncServer server, Int id, Int cost) implements ConnectionThread {
  Int br = 0;
  Int ar = 0;
  SyncServerClientCoordinator coord;
  Maybe<Command> cmd = Nothing;
  Schedules schedules = EmptySet;
  
  ReplicationSnapshot startReplicationUpdate(){
    assert ( size(schedules) == 1 );
    Schedule schedule = snd(next(schedules));
    Fut<Unit> rp = coord!startReplicationUpdate(id);
    await rp?;
    Fut<ReplicationSnapshot> sp = server!getReplicationSnapshot();
    return sp.get;
  }
  Unit finishReplicationUpdate(){
    Fut<Unit> rp = coord!finishReplicationUpdate(id);
    await rp?;
  }
  Unit run(){
    Fut<SyncServerClientCoordinator> c = server!getCoordinator();
    await c?;
    coord = c.get;
    [job]
    await ( cmd != Nothing );
    schedules = this.sendSchedule();
    if ( ( cmd != Just( ListSchedule ) ) ){
      ReplicationSnapshot snapshot = this.startReplicationUpdate();
      Fut<TransactionId> idf = snapshot!getIndexingId();
      await idf?;
      TransactionId tid = idf.get;
      Fut<Bool> b = job!registerReplicationItems(tid);
      await b?;
      Bool register = b.get;
      Set<Set<File>> filesets = EmptySet;
      if ( register ){
        Fut<Set<ServerReplicationItem>> nis = snapshot!getItems(ssname(fromJust(cmd)));
        await nis?;
        Set<ServerReplicationItem> newitems = nis.get;
        filesets = this.registerItems(newitems);
      }
      Fut<Unit> rp = job!command(StartSnapShot);
      await rp?;
      while (hasNext(filesets)) {
        Pair<Set<Set<File>>, Set<File>> nfs = next(filesets);
        filesets = fst(nfs);
        Set<File> fileset = snd(nfs);
        this.transferItems(fileset);
      }
      rp = job!command(EndSnapShot);
      await rp?;
      this.finishReplicationUpdate();
    }
  }
  Set<Schedule> sendSchedule(){
    assert isJust(cmd);
    Set<Schedule> results = EmptySet;
    if ( ( cmd == Just( ListSchedule ) ) ){
      Fut<Set<Schedule>> ssf = server!listSchedules();
      await ssf?;
      results = ssf.get;
    } else {
      Fut<Schedule> ssf = server!getSchedule(ssname(fromJust(cmd)));
      await ssf?;
      Schedule s = ssf.get;
      results = Insert( s, EmptySet );
    }
    Fut<Unit> rp = job!receiveSchedule(results);
    await rp?;
    return results;
  }
  ClientId forClient(){
    Fut<ClientId> id = job!forClient();
    return id.get;
  }
  [Atomic]
  Unit command(Command c){
    cmd = Just( c );
  }
  Set<Set<File>> registerItems(Set<ServerReplicationItem> items){
    Set<Set<File>> regs = EmptySet;
    List<ServerReplicationItem> itemsList = setToList(items);
    while (( length(itemsList) > 0 )) {
      ServerReplicationItem item = head(itemsList);
      itemsList = tail(itemsList);
      Fut<FileEntry> entryf = item!getContents();
      await entryf?;
      FileEntry entry = entryf.get;
      regs = Insert( entryToFiles(entry), regs );
    }
    return regs;
  }
  Unit transferItems(Set<File> fileset){
    while (hasNext(fileset)) {
      Pair<Set<File>, File> nf = next(fileset);
      fileset = fst(nf);
      File file = snd(nf);
      FileSize tsize = fileContent(file);
      Fut<Unit> rp = job!command(AppendSearchFile);
      await rp?;
      Fut<Maybe<FileSize>> fs = job!processFile(fst(file));
      await fs?;
      Maybe<FileSize> content = fs.get;
      FileSize size = 0;
      if ( isJust(content) ){
        size = fromJust(content);
      }
      if ( ( size > tsize ) ){
        rp = job!command(OverwriteFile);
        await rp?;
        rp = job!processContent(file);
        await rp?;
      } else {
        if ( ( ( tsize - size ) > 0 ) ){
          rp = job!command(ContinueFile);
          await rp?;
          file = file(fst(file), ( tsize - size ));
          rp = job!processContent(file);
          await rp?;
        } else {
          rp = job!command(SkipFile);
          await rp?;
        }
      }
    }
    Fut<Unit> rp = job!command(EndSearchFile);
    await rp?;
  }
  }


module ReplicationSystem.Schedulers;

export *;

import * from ABS.Scheduler;
import * from ReplicationSystem.Environment.Files;
import * from ABS.StdLib;

def Int defaultScheduleCost(Schedule s) = 
  case s {
    NoSchedule => 1;
    Schedule( n, _, _, i ) => case n {
      "Data" => 6;
      "Business rules" => 6;
      "Search" => 6;
    };
  };

def Process scheduleHighestCostScheduler(List<Process> q) = 
  scheduleCostSchedulerH(head(q), tail(q));

def Process scheduleCostSchedulerH(Process h, List<Process> t) = 
  case t {
    Nil => h;
    Cons( h2, t2 ) => case ( value(h) > value(h2) ) {
      True => scheduleCostSchedulerH(h, t2);
      False => scheduleCostSchedulerH(h2, t2);
    };
  };

def Process scheduleLoweestCostScheduler(List<Process> q) = 
  scheduleCostSchedulerL(head(q), tail(q));

def Process scheduleCostSchedulerL(Process h, List<Process> t) = 
  case t {
    Nil => h;
    Cons( h2, t2 ) => case ( value(h) < value(h2) ) {
      True => scheduleCostSchedulerL(h, t2);
      False => scheduleCostSchedulerL(h2, t2);
    };
  };

def Process edf(List<Process> q) = 
  edfH(head(q), tail(q));

def Process edfH(Process h, List<Process> t) = 
  case t {
    Nil => h;
    Cons( h2, t2 ) => edfH(h, t2);
  };

def Process hcf(List<Process> q) = 
  hcfH(head(q), tail(q));

def Process hcfH(Process h, List<Process> t) = 
  case t {
    Nil => h;
    Cons( h2, t2 ) => case durationLessThan(cost(h), cost(h2)) {
      False => hcfH(h, t2);
      True => hcfH(h2, t2);
    };
  };


module ReplicationSystem.Server.SyncServerAcceptor;

export *;

import * from ReplicationSystem.Environment.DataTypes;
import * from ReplicationSystem.Client.Interfaces;
import * from ReplicationSystem.Server.Interfaces;
import * from ReplicationSystem.Server.ConnectionThread;
import * from ABS.StdLib;

class SyncServerAcceptorImpl([Final]SyncServer server) implements ServerAcceptor {
  Int threads = 0;
  
  ConnectionThread getConnection(ClientJob job, Int cost){
    ConnectionThread thread = null;
    Fut<Bool> sf = server!isShutdownRequested();
    Bool shutdown = sf.get;
    if ( ~ shutdown ){
      thread = new ConnectionThreadImpl(job, server, threads, cost);
      threads = ( threads + 1 );
    }
    return thread;
  }
  Unit finish(ConnectionThread thread){
    
  }
  }


module ReplicationSystem.Environment.DataBases;

export *;

import * from ReplicationSystem.Environment.DataTypes;
import * from ReplicationSystem.Environment.Files;
import * from ReplicationSystem.Environment.Interfaces;
import * from ABS.StdLib;

def Map<A, B> firstValues<A, B>(Map<A, List<B>> mp, B default) = 
  case mp {
    EmptyMap => EmptyMap;
    InsertAssoc( Pair( x, ls ), xs ) => case ls {
      Nil => InsertAssoc( Pair( x, default ), firstValues(xs, default) );
      Cons( y, ys ) => InsertAssoc( Pair( x, y ), firstValues(xs, default) );
    };
  };

[Plain]
class DataBaseImpl implements ServerDataBase, ClientDataBase, UpdatableDataBase {
  Int count = 0;
  Map<String, List<TransactionId>> transactions = EmptyMap;
  TransactionHistories histories = Nil;
  Pair<TransactionId, Map<FileId, FileContent>> currentTransaction = Pair( - 1, EmptyMap );
  Directory rdir = rootDir();
  
  [Atomic]
  TransactionHistories getTransactions(){
    return histories;
  }
  [Atomic]
  Unit update(Map<FileId, FileContent> changes){
    rdir = updateDirWithContents(rdir, changes);
    currentTransaction = Pair( ( fst(currentTransaction) + 1 ), changes );
    histories = Cons( currentTransaction, histories );
  }
  [Atomic]
  TransactionId refresh(){
    count = ( count + 1 );
    return fst(currentTransaction);
  }
  [Atomic]
  FileContent getContent(FileId qualified){
    Maybe<FileContent> result = Nothing;
    if ( ( qualified == rootId() ) ){
      result = Just( getFileContent(Right( rdir )) );
    } else {
      result = getFromEntryIn(rdir, qualified);
    }
    assert ( result != Nothing );
    return fromJust(result);
  }
  [Atomic]
  Bool hasFile(FileId qualified){
    return hasQualifiedEntriesIn(rdir, qualified);
  }
  [Atomic]
  Directory getRoot(){
    return rdir;
  }
  [Atomic]
  Bool prepareReplicationItem(TransactionId p, Schedule schedule){
    Bool result = False;
    String name = schedname(schedule);
    List<TransactionId> tids = lookupDefault(transactions, name, Nil);
    if ( ~ contains(set(tids), p) ){
      transactions = put(transactions, name, Cons( p, tids ));
      result = True;
    }
    return result;
  }
  [Atomic]
  Map<String, TransactionId> lastTransactionIds(){
    return firstValues(transactions, - 1);
  }
  [Atomic]
  Unit updateFile(FileId qualified, FileSize size){
    rdir = updateDirWithFile(rdir, file(qualified, size));
  }
  [Atomic]
  Maybe<FileContent> listFilesAt(FileId qualifiedDir){
    return getFromEntryIn(rdir, qualifiedDir);
  }
  [Atomic]
  Set<FileId> listFiles(){
    Set<FileId> allqualified = getFileIdFromDir(rdir);
    return allqualified;
  }
  }


module ReplicationSystem.Installation;


import * from ReplicationSystem.Main;
import * from ABS.StdLib;


{
  new ReplicationSystemMain();
}module ReplicationSystem.Server.ReplicationSnapshot;

export *;

import * from ReplicationSystem.Environment.Files;
import * from ReplicationSystem.Environment.DataTypes;
import * from ReplicationSystem.Environment.Interfaces;
import * from ReplicationSystem.Environment.ReplicationSnapshot.Interfaces;
import SearchDirectoryItem from ReplicationSystem.Server.ReplicationItem;
import * from ABS.StdLib;

class ReplicationSnapshotImpl(ServerDataBase db, Schedules schedules) implements ReplicationSnapshot {
  Int count = 0;
  Int update = 0;
  TransactionId tid = - 1;
  Bool clean = True;
  Map<String, Set<ServerReplicationItem>> repItems = EmptyMap;
  
  Set<ServerReplicationItem> getItems(String name){
    return lookupDefault(repItems, name, EmptySet);
  }
  [Atomic]
  Unit refreshSnapshot(){
    count = ( count + 1 );
    if ( clean ){
      tid = db.refresh();
      update = ( update + 1 );
      this.createReplicationItems();
      Set<String> names = keys(repItems);
      while (hasNext(names)) {
        Pair<Set<String>, String> nn = next(names);
        Set<ServerReplicationItem> titems = lookupUnsafe(repItems, snd(nn));
        while (hasNext(titems)) {
          Pair<Set<ServerReplicationItem>, ServerReplicationItem> ni = next(titems);
          ServerReplicationItem item = snd(ni);
          item.refresh();
          titems = fst(ni);
        }
        names = fst(nn);
      }
      clean = False;
    }
  }
  [Atomic]
  Unit createReplicationItems(){
    Schedules tsc = schedules;
    while (hasNext(tsc)) {
      Pair<Schedules, Schedule> ns = next(tsc);
      this.replicationItems(snd(ns));
      tsc = fst(ns);
    }
  }
  [Atomic]
  Unit replicationItems(Schedule schedule){
    List<Item> is = items(schedule);
    Set<ServerReplicationItem> sitems = EmptySet;
    while (( is != Nil )) {
      ServerReplicationItem r = this.replicationItem(head(is));
      sitems = Insert( r, sitems );
      is = tail(is);
    }
    repItems = InsertAssoc( Pair( schedname(schedule), sitems ), repItems );
  }
  [Atomic]
  ServerReplicationItem replicationItem(Item i){
    ServerReplicationItem item = null;
    if ( isSearchItem(i) ){
      item = new local SearchDirectoryItem(left(item(i)), db);
    }
    return item;
  }
  Unit clearSnapshot(){
    repItems = EmptyMap;
    clean = True;
  }
  Int getIndexingId(){
    return tid;
  }
  }


module ReplicationSystem.Environment.StateMachine;

export *;

import * from ReplicationSystem.Environment.Files;
import * from ABS.StdLib;

data State = Start| WaitToBoot| Booting| WaitToReplicate| WorkOnReplicate| End;

type StateMachine = Map<State, Set<State>>;

def Map<State, Set<State>> stateMachine() = 
  let ( Pair<State, Set<State>> start ) = Pair( Start, set(Cons( WaitToBoot, Nil )) ) in let ( Pair<State, Set<State>> waitToBoot ) = Pair( WaitToBoot, set(Cons( Booting, Cons( End, Nil ) )) ) in let ( Pair<State, Set<State>> booting ) = Pair( Booting, set(Cons( WaitToBoot, Cons( WaitToReplicate, Cons( End, Nil ) ) )) ) in let ( Pair<State, Set<State>> waitToReplicate ) = Pair( WaitToReplicate, set(Cons( WaitToBoot, Cons( WorkOnReplicate, Cons( End, Nil ) ) )) ) in let ( Pair<State, Set<State>> workOnReplicate ) = Pair( WorkOnReplicate, set(Cons( WaitToBoot, Cons( WaitToReplicate, Cons( End, Nil ) ) )) ) in map(Cons( start, Cons( waitToBoot, Cons( booting, Cons( waitToReplicate, Cons( workOnReplicate, Nil ) ) ) ) ));


module ReplicationSystem.Client.ClientJob;

export ClientJobImpl;

import * from ReplicationSystem.Environment.Files;
import * from ReplicationSystem.Environment.DataTypes;
import * from ReplicationSystem.Environment.StateMachine;
import * from ReplicationSystem.Schedulers;
import * from ReplicationSystem.Server.Interfaces;
import * from ReplicationSystem.Client.Interfaces;
import * from ReplicationSystem.Environment.Interfaces;
import * from ABS.StdLib;

class ClientJobImpl([Final]Int maxJobs, [Far] [Final]InternalClient client, [Final]JobType job, [Final]Schedule schedule, [Final]Int id) implements ClientJob {
  Maybe<Int> deadline = Nothing;
  Maybe<JobData> jd = Nothing;
  Command start = EmptyCommand;
  Command command = EmptyCommand;
  Schedules schedules = EmptySet;
  ClientId clientId = - 1;
  TransactionId transactionId = - 1;
  ConnectionThread thread = null;
  [Far]
  ClientDataBase db;
  
  ConnectionThread getConnectionThread(){
    Fut<ServerAcceptor> fs = client!getAcceptor();
    ServerAcceptor acceptor = fs.get;
    Fut<ConnectionThread> t = acceptor!getConnection(this, defaultScheduleCost(schedule));
    await t?;
    return t.get;
  }
  Unit clientDB(){
    Fut<ClientDataBase> fd = client!getClientDataBase();
    db = fd.get;
  }
  Unit establishSchedule(){
    Fut<Int> jcf = client!jobCount();
    Int stats = jcf.get;
    if ( ( stats < maxJobs ) ){
      Schedules ss = schedules;
      while (hasNext(ss)) {
        Pair<Schedules, Schedule> nt = next(ss);
        ss = fst(nt);
        Schedule s = snd(nt);
        client!scheduleJob(this, Replication, s);
      }
    }
  }
  Unit executeJob(){
    Fut<ClientId> fut = client!getId();
    clientId = fut.get;
    this.clientDB();
    ConnectionThread thread = this.getConnectionThread();
    if ( ( thread != null ) ){
      if ( ( job == Boot ) ){
        this.becomeState(Booting);
        thread!command(ListSchedule);
        [thread]
        await ( schedules != EmptySet );
        this!establishSchedule();
      } else {
        this.becomeState(WorkOnReplicate);
        thread!command(SearchSchedule( schedname(schedule) ));
        [thread]
        await ( schedules != EmptySet );
        this!establishSchedule();
        [thread]
        await ( start == StartSnapShot );
        [thread]
        await ( command == EndSnapShot );
      }
      Fut<Bool> sd = client!isShutdownRequested();
      Bool shutDown = sd.get;
      if ( ~ shutDown ){
        this.becomeState(WaitToReplicate);
      }
      this.nextJob();
    }
    client!finishJob();
  }
  Unit nextJob(){
    client!nextJob();
  }
  Unit becomeState(State state){
    if ( ( state == WaitToBoot ) ){
      Fut<Unit> unit = client!waitToBoot();
      unit.get;
    } else if ( ( state == Booting ) ){
      Fut<Unit> unit = client!boot();
      unit.get;
    } else if ( ( state == WorkOnReplicate ) ){
      Fut<Unit> unit = client!replicate();
      unit.get;
    } else if ( ( state == WaitToReplicate ) ){
      Fut<Unit> unit = client!waitToReplicate();
      unit.get;
    } else if ( ( state == End ) ){
      Fut<Unit> unit = client!end();
      unit.get;
    }
  }
  ClientId forClient(){
    return clientId;
  }
  Unit shutDownClient(){
    Fut<Bool> bf = client!isShutdownRequested();
    await bf?;
    Bool bool = bf.get;
    if ( ~ bool ){
      Fut<Unit> unit = client!requestShutDown();
      await unit?;
      unit.get;
      this.becomeState(End);
    }
  }
  Bool registerReplicationItems(TransactionId id){
    Fut<Bool> reg = db!prepareReplicationItem(id, schedule);
    Bool rg = reg.get;
    if ( rg ){
      transactionId = id;
    }
    return rg;
  }
  Bool hasFile(FileId id){
    Fut<Bool> he = db!hasFile(id);
    await he?;
    return he.get;
  }
  Maybe<FileSize> processFile(FileId id){
    Maybe<FileSize> result = Nothing;
    Bool hasfile = this.hasFile(id);
    if ( hasfile ){
      Fut<FileContent> contentf = db!getContent(id);
      await contentf?;
      FileContent content = contentf.get;
      if ( isFile(content) ){
        FileSize size = content(content);
        result = Just( size );
      }
    }
    return result;
  }
  Unit overwrite(File file){
    FileId id = fst(file);
    FileSize size = fileContent(file);
    Fut<Unit> u = db!updateFile(id, size);
    await u?;
  }
  Unit continue(File file){
    FileId id = fst(file);
    FileSize size = fileContent(file);
    Bool he = this.hasFile(id);
    FileSize fsize = 0;
    if ( he ){
      Fut<FileContent> s = db!getContent(fst(file));
      await s?;
      FileContent c = s.get;
      fsize = content(c);
    }
    size = ( size + fsize );
    Fut<Unit> u = db!updateFile(id, size);
    await u?;
  }
  Unit processContent(File file){
    [thread]
    await isAppendCommand(command);
    if ( ( command == SkipFile ) ){
      skip;
    } else if ( ( command == OverwriteFile ) ){
      this.overwrite(file);
    } else if ( ( command == ContinueFile ) ){
      this.continue(file);
    }
  }
  [Atomic]
  Unit command(Command c){
    if ( ( c == StartSnapShot ) ){
      start = c;
    } else {
      command = c;
    }
  }
  Unit receiveSchedule(Schedules schedules){
    schedules = schedules;
  }
  }


module ReplicationSystem.Client.Interfaces;

export *;

import * from ReplicationSystem.Environment.Files;
import * from ReplicationSystem.Environment.DataTypes;
import * from ReplicationSystem.Environment.Interfaces;
import * from ReplicationSystem.Interfaces;
import * from ReplicationSystem.Server.Interfaces;
import * from Replication.Network;
import * from ABS.StdLib;

interface Client {
  ClientDataBase getClientDataBase();
  DataBase getDataBase();
  Bool isShutdownRequested();
  Unit requestShutDown();}

interface ClientConnector extends Client {
  Unit setAcceptor(ServerAcceptor acceptor);
  Unit setNetwork(Network network);}

interface SyncClient extends Client, ClientStateMachine {
  [Far]
  ServerAcceptor getAcceptor();}

interface InternalClient extends SyncClient {
  ClientId getId();
  [Atomic]
  Int jobCount();
  Unit nextJob();
  Unit scheduleJob(ClientJob job, JobType jb, Schedule schedule);
  Unit finishJob();}

interface ClientStateMachine {
  Unit waitToBoot();
  Unit boot();
  Unit start();
  Unit waitToReplicate();
  Unit replicate();
  Unit end();}

interface ClientJob {
  Bool registerReplicationItems(TransactionId id);
  Maybe<FileSize> processFile(FileId id);
  Unit processContent(File file);
  Unit receiveSchedule(Schedules schedules);
  Unit executeJob();
  ClientId forClient();
  [Atomic]
  Unit command(Command command);}


module ReplicationSystem.Server.Update;

export *;

import * from Replication.Network;
import * from ReplicationSystem.Environment.DataTypes;
import * from ReplicationSystem.Server.Interfaces;
import * from ReplicationSystem.Environment.Interfaces;
import * from ReplicationSystem.Environment.Files;
import * from ReplicationSystem.ReplicationSystem;
import * from ABS.StdLib;

class UpdaterImpl([Final]Int updates, SyncServer server, ReplicationSystem sys) implements Updater {
  Network network;
  Bool sd = False;
  List<Map<FileId, FileContent>> histories = Nil;
  [Final]
  Int best = 5;
  [Final]
  Int worst = 10;
  [Final]
  FileSize limit = 5;
  List<FileId> replicationItems = list(Cons( "indices/itemstore/i1", Cons( "indices/itemstore/i2", Cons( "indices/itemstore/log/j1", Cons( "indices/search/s1", Cons( "indices/search/s2", Cons( "indices/tree/t1", Cons( "indices/tree/log/j2", Cons( "config/random.xml", Cons( "config/business.xml", Nil ) ) ) ) ) ) ) ) ));
  
  Unit run(){
    [sys]
    await ( network != null );
    Fut<UpdatableDataBase> fd = server!getUpdatableDataBase();
    UpdatableDataBase db = fd.get;
    Map<FileId, FileContent> changes = EmptyMap;
    Int count = 0;
    Bool pd = False;
    while (( ~ pd && ( ( updates < 0 ) || ( count < updates ) ) )) {
      changes = this.makeChange();
      histories = Cons( changes, histories );
      if ( ( changes != EmptyMap ) ){
        Fut<Unit> u = db!update(changes);
        u.get;
      }
      suspend;
      Fut<Bool> fb = network!powerDown();
      pd = fb.get;
      count = ( count + 1 );
    }
    this.shutDown();
  }
  Map<FileId, FileContent> makeChange(){
    List<FileId> fs = this.chooseFile();
    Map<FileId, FileContent> result = this.assignContent(fs, limit);
    return result;
  }
  Unit setNetwork(Network network){
    this.network = network;
  }
  Unit shutDown(){
    network!shutDownUpdater();
  }
  Map<FileId, FileContent> assignContent(List<FileId> w, FileSize limit){
    Map<FileId, FileContent> result = EmptyMap;
    while (( w != Nil )) {
      Int rand = random(limit);
      result = InsertAssoc( file(head(w), ( rand + 1 )), result );
      w = tail(w);
    }
    return result;
  }
  List<FileId> chooseFile(){
    List<FileId> files = replicationItems;
    List<FileId> result = Nil;
    while (( files != Nil )) {
      Int rand = random(2);
      if ( ( rand == 0 ) ){
        result = Cons( head(files), result );
      }
      files = tail(files);
    }
    return result;
  }
  }


module ReplicationSystem.Server.ReplicationItem;

export *;

import * from ReplicationSystem.Environment.Interfaces;
import * from ReplicationSystem.Environment.ReplicationSnapshot.Interfaces;
import * from ReplicationSystem.Environment.DataTypes;
import * from ReplicationSystem.Environment.Files;
import * from ABS.StdLib;

class SearchDirectoryItem(FileId qualified, ServerDataBase db) implements ServerReplicationItem {
  Directory snapshot = updateDirWithDir(rootDir(), emptyDir(qualified));
  
  FileEntry getContents(){
    return dirContent(snapshot);
  }
  FileId getAbsoluteDir(){
    return qualified;
  }
  [Atomic]
  Unit cleanup(){
    snapshot = updateDirWithDir(rootDir(), emptyDir(qualified));
  }
  [Atomic]
  Directory getState(){
    return snapshot;
  }
  [Atomic]
  Unit setState(Directory dir){
    snapshot = dir;
  }
  Command getCommand(){
    return AppendSearchFile;
  }
  ReplicationItemType getType(){
    return SearchReplicationDirectory;
  }
  [Atomic]
  Unit refresh(){
    Maybe<FileContent> ffs = db.listFilesAt(qualified);
    if ( ( ffs != Nothing ) ){
      FileContent content = fromJust(ffs);
      assert isDirectory(content);
      snapshot = updateDirWithDir(snapshot, dir(qualified, entries(content)));
    }
  }
  }


module ReplicationSystem.ReplicationSystem;

export *;

import * from ReplicationSystem.Environment.DataTypes;
import * from ReplicationSystem.Environment.Files;
import * from ReplicationSystem.Environment.Interfaces;
import * from ReplicationSystem.Server.Interfaces;
import * from ReplicationSystem.Client.Interfaces;
import * from ReplicationSystem.Environment.DataBases;
import * from ReplicationSystem.Client;
import * from ReplicationSystem.Server;
import * from ReplicationSystem.Server.Update;
import * from ReplicationSystem.Server.SyncServerAcceptor;
import * from Replication.Network;
import * from ReplicationSystem.Tests;
import * from ABS.StdLib;

interface ReplicationSystem {
  }

class ReplicationSystem([Final]Int maxUpdates, [Final]List<Schedule> schedules, [Final]Int maxJobs, [Final]Set<ClientId> cids) implements ReplicationSystem {
  
  
  Unit run(){
    [Far]
    SyncServer syncserver = new SyncServerImpl(listToSet(schedules), cids);
    [Far]
    ServerAcceptor acceptor = new SyncServerAcceptorImpl(syncserver);
    List<[Far]ClientConnector> syncclients = Nil;
    Set<ClientId> iterator = cids;
    while (hasNext(iterator)) {
      Pair<Set<ClientId>, ClientId> nt = next(iterator);
      ClientConnector syncclient = new SyncClientImpl(maxJobs, snd(nt), this);
      syncclients = Cons( syncclient, syncclients );
      iterator = fst(nt);
    }
    Updater updater = new UpdaterImpl(maxUpdates, syncserver, this);
    Network network = new Network(syncserver, length(syncclients));
    Fut<Unit> fu = updater!setNetwork(network);
    fu.get;
    List<ClientConnector> clientIterator = syncclients;
    while (( length(clientIterator) > 0 )) {
      ClientConnector syncclient = head(clientIterator);
      fu = syncclient!setNetwork(network);
      fu.get;
      syncclient!setAcceptor(acceptor);
      clientIterator = tail(clientIterator);
    }
  }
  }


module ReplicationSystem.Server.Interfaces;

export *;

import * from ReplicationSystem.Environment.Interfaces;
import * from ReplicationSystem.Environment.Files;
import * from ReplicationSystem.Environment.DataTypes;
import * from ReplicationSystem.Environment.ReplicationSnapshot.Interfaces;
import ClientJob from ReplicationSystem.Client.Interfaces;
import * from ABS.StdLib;

interface SyncServerClientCoordinator {
  Unit startReplicationUpdate(Int worker);
  Unit finishReplicationUpdate(Int worker);
  Unit setSnapshot(ReplicationSnapshot snapshot);}

interface ServerAcceptor {
  [Far]
  ConnectionThread getConnection(ClientJob job, Int cost);
  Unit finish(ConnectionThread thread);}

interface ConnectionThread {
  ClientId forClient();
  [Atomic]
  Unit command(Command command);}

interface ServerNode {
  UpdatableDataBase getUpdatableDataBase();
  Schedules listSchedules();
  Schedule getSchedule(String name);
  DataBase getDataBase();
  Bool isShutdownRequested();
  Unit requestShutDown();}

interface SyncServer extends ServerNode {
  [Far]
  SyncServerClientCoordinator getCoordinator();
  [Near]
  ReplicationSnapshot getReplicationSnapshot();}

interface InternalServer extends SyncServer {
  Unit debug();}


module ReplicationSystem.Server.SyncServerClientCoordinator;

export SyncServerClientCoordinatorImpl;

import * from ReplicationSystem.Environment.DataTypes;
import * from ReplicationSystem.Environment.ReplicationSnapshot.Interfaces;
import * from ReplicationSystem.Server.Interfaces;
import * from ABS.StdLib;

[COG]
class SyncServerClientCoordinatorImpl(Set<ClientId> clients) implements SyncServerClientCoordinator {
  Int count = 0;
  Bool shutDown = False;
  ServerAcceptor acceptor;
  Set<Int> threads = EmptySet;
  [Far]
  ReplicationSnapshot snapshot;
  
  Unit setSnapshot(ReplicationSnapshot snapshot){
    this.snapshot = snapshot;
  }
  Unit startReplicationUpdate(Int thread){
    assert ~ contains(threads, thread);
    threads = Insert( thread, threads );
    if ( ( size(threads) == 1 ) ){
      this.refreshSnapShot();
    }
  }
  Unit finishReplicationUpdate(Int thread){
    if ( contains(threads, thread) ){
      if ( ( size(threads) == 1 ) ){
        this.clearSnapshot();
      }
      threads = remove(threads, thread);
    }
  }
  Unit clearSnapshot(){
    Fut<Unit> unit = snapshot!clearSnapshot();
    unit.get;
  }
  Unit refreshSnapShot(){
    count = ( count + 1 );
    Fut<Unit> unit = snapshot!refreshSnapshot();
    unit.get;
  }
  TransactionId getCurrentTransactionId(){
    Fut<TransactionId> cf = snapshot!getIndexingId();
    return cf.get;
  }
  }


module ReplicationSystem.Tests;

export TesterImpl, Tester;

import * from ReplicationSystem.Environment.DataTypes;
import * from ReplicationSystem.Environment.Files;
import * from ReplicationSystem.Environment.Interfaces;
import * from ReplicationSystem.Interfaces;
import * from ReplicationSystem.Client.Interfaces;
import * from ReplicationSystem.Server.Interfaces;
import * from ABS.StdLib;

class TesterImpl(ServerNode expected, ClientDataBase actual) implements Tester {
  Schedules schedules = EmptySet;
  Map<String, TransactionId> scheduleResults = EmptyMap;
  Set<Triple<FileId, FileContent, FileContent>> result = EmptySet;
  
  Unit analyse(){
    Fut<UpdatableDataBase> fe = expected!getUpdatableDataBase();
    UpdatableDataBase e = fe.get;
    Fut<Schedules> schf = expected!listSchedules();
    schedules = schf.get;
    Fut<TransactionHistories> tf = e!getTransactions();
    TransactionHistories transactions = tf.get;
    Fut<Map<String, TransactionId>> idf = actual!lastTransactionIds();
    scheduleResults = idf.get;
    Fut<Directory> rf = actual!getRoot();
    Directory act = rf.get;
    this.checkDatas(scheduleResults, reverse(transactions), act);
  }
  Unit checkDatas(Map<String, TransactionId> tids, TransactionHistories th, Directory act){
    while (hasNext(schedules)) {
      Pair<Schedules, Schedule> nt = next(schedules);
      schedules = fst(nt);
      Schedule s = snd(nt);
      Int tid = lookupDefault(tids, schedname(s), - 1);
      if ( ( tid != - 1 ) ){
        Directory exp = applyChanges(rootDir(), th, tid);
        List<Item> is = items(s);
        while (( is != Nil )) {
          this.checkData(head(is), exp, act);
          is = tail(is);
        }
      }
    }
  }
  Bool hasFile(DataBase b, FileId f){
    Fut<Bool> fb = b!hasFile(f);
    return fb.get;
  }
  Unit checkData(Item i, Directory exp, Directory act){
    if ( isLeft(item(i)) ){
      FileId id = left(item(i));
      Bool eh = hasQualifiedEntriesIn(exp, id);
      Bool ah = hasQualifiedEntriesIn(act, id);
      assert ( eh == ah );
      if ( eh ){
        FileContent ce = fromJust(getFromEntryIn(exp, id));
        FileContent ca = fromJust(getFromEntryIn(act, id));
        if ( isFile(ce) ){
          this.compareFile(file(id, content(ce)), file(id, content(ca)));
        } else {
          this.compareDir(dir(id, entries(ce)), dir(id, entries(ca)));
        }
      }
    }
    if ( isRight(item(i)) ){
      FileId id = fst(right(item(i)));
      String pattern = snd(right(item(i)));
      Bool eh = hasQualifiedEntriesIn(exp, id);
      Bool ah = hasQualifiedEntriesIn(act, id);
      if ( ( ( eh != ah ) && eh ) ){
        FileContent ce = fromJust(getFromEntryIn(exp, id));
        assert ~ isFile(ce);
        assert emptySet(filters(pattern, getFileIdFromDir(dir(id, entries(ce)))));
      } else if ( eh ){
        FileContent ce = fromJust(getFromEntryIn(exp, id));
        FileContent ca = fromJust(getFromEntryIn(act, id));
        if ( isFile(ce) ){
          if ( filter(pattern, id) ){
            this.compareFile(file(id, content(ce)), file(id, content(ca)));
          }
        } else {
          this.compareDirWithPattern(pattern, dir(id, entries(ce)), dir(id, entries(ca)));
        }
      }
    }
  }
  Unit compareDirWithPattern(String pattern, Directory e, Directory a){
    this.compareEntrySets(filters(pattern, getFileIdFromDir(e)), filters(pattern, getFileIdFromDir(a)), qualifyFileEntry(entries(snd(e)), fst(e)), qualifyFileEntry(entries(snd(a)), fst(a)));
  }
  Unit compareDir(Directory e, Directory a){
    this.compareEntrySets(getFileIdFromDir(e), getFileIdFromDir(a), qualifyFileEntry(entries(snd(e)), fst(e)), qualifyFileEntry(entries(snd(a)), fst(a)));
  }
  Unit compareEntrySets(Set<FileId> eids, Set<FileId> aids, Map<FileId, FileContent> ee, Map<FileId, FileContent> ae){
    assert ( size(eids) == size(aids) );
    while (hasNext(eids)) {
      Pair<Set<FileId>, FileId> nd = next(eids);
      FileId id = snd(nd);
      eids = fst(nd);
      FileContent es = lookupDefault(ee, id, NoContent);
      FileContent as = lookupDefault(ae, id, NoContent);
      result = Insert( Triple( id, es, as ), result );
      assert ( es == as );
    }
  }
  Unit compareFile(File e, File a){
    FileId id = getFileId(Left( e ));
    FileContent es = getFileContent(Left( e ));
    FileContent as = getFileContent(Left( a ));
    result = Insert( Triple( id, es, as ), result );
    assert ( es == as );
  }
  }


module ReplicationSystem.Environment.Interfaces;

export *;

import * from ReplicationSystem.Environment.Files;
import * from ReplicationSystem.Environment.DataTypes;
import * from Replication.Network;
import * from ABS.StdLib;

interface DataBase {
  [Atomic]
  FileContent getContent(FileId fId);
  [Atomic]
  Bool hasFile(FileId fId);
  [Atomic]
  Set<FileId> listFiles();
  [Atomic]
  Maybe<FileContent> listFilesAt(FileId dir);
  [Atomic]
  Directory getRoot();}

interface UpdatableDataBase extends ServerDataBase {
  [Atomic]
  Unit update(Map<FileId, FileContent> changes);
  [Atomic]
  TransactionHistories getTransactions();}

interface ServerDataBase extends DataBase {
  [Atomic]
  TransactionId refresh();}

interface ClientDataBase extends DataBase {
  [Atomic]
  Bool prepareReplicationItem(TransactionId p, Schedule schedule);
  [Atomic]
  Unit updateFile(FileId fId, FileSize size);
  [Atomic]
  Map<String, TransactionId> lastTransactionIds();}

interface Updater {
  Unit setNetwork(Network netWork);}


module ReplicationSystem.Environment.DataTypes;

export *;

import * from ABS.DC;
import * from ABS.StdLib;

def List<A> concatenates<A>(List<List<A>> lists) = 
  case lists {
    Nil => Nil;
    Cons( x, xs ) => concatenate(x, concatenates(xs));
  };

def Map<A, B> join<A, B>(Map<A, B> f, Map<A, B> g) = 
  case g {
    EmptyMap => f;
    InsertAssoc( x, xs ) => case contains(keys(f), fst(x)) {
      True => join(f, xs);
      False => InsertAssoc( x, join(f, xs) );
    };
  };

data Command = StartSnapShot| EndSnapShot| ListSchedule| SearchSchedule(String ssname)| EndSearchFile| AppendSearchFile| ReceivePatternFile| SkipFile| ContinueFile| OverwriteFile| EmptyCommand;

data JobType = Replication| Boot;

data ReplicationItemType = SearchReplicationDirectory| LogReplicationItem| ReplicationFilePattern;

type ClientId = Int;

type TransactionId = Int;

def A fromJustDefault<A>(Maybe<A> m, A a) = 
  case m {
    Just( j ) => j;
    Nothing => a;
  };

def Set<A> fsts<A, B>(Set<Pair<A, B>> ps) = 
  case ps {
    EmptySet => EmptySet;
    Insert( x, xs ) => Insert( fst(x), fsts(xs) );
  };

def Set<B> snds<A, B>(Set<Pair<A, B>> ps) = 
  case ps {
    EmptySet => EmptySet;
    Insert( x, xs ) => Insert( snd(x), snds(xs) );
  };

def Bool range(List<Int> vals, Int limit, Bool strict) = 
  case vals {
    Nil => ~ strict;
    _ => let ( Int r ) = ( maximum(vals) - minimum(vals) ) in case strict {
      True => ( r == limit );
      False => ( r <= limit );
    };
  };

def Int maximum(List<Int> l) = 
  case l {
    Cons( x, xs ) => maximum0(xs, x);
  };

def Int maximum0(List<Int> l, Int i) = 
  case l {
    Nil => i;
    Cons( x, xs ) => maximum0(xs, max(x, i));
  };

def Int minimum(List<Int> l) = 
  case l {
    Cons( x, xs ) => minimum0(xs, x);
  };

def Int minimum0(List<Int> l, Int i) = 
  case l {
    Nil => i;
    Cons( x, xs ) => minimum0(xs, min(x, i));
  };

def List<A> setToList<A>(Set<A> a) = 
  case a {
    EmptySet => Nil;
    Insert( x, xs ) => Cons( x, setToList(xs) );
  };

def Set<A> listToSet<A>(List<A> a) = 
  case a {
    Nil => EmptySet;
    Cons( x, xs ) => Insert( x, listToSet(xs) );
  };

def Map<A, B> setToMap<A, B>(Set<A> a, B b) = 
  case a {
    EmptySet => EmptyMap;
    Insert( x, xs ) => InsertAssoc( Pair( x, b ), setToMap(xs, b) );
  };

def List<A> take<A>(List<A> ss, Int i) = 
  case i {
    0 => Nil;
    _ => case ss {
      Nil => Nil;
      Cons( x, xs ) => Cons( x, take(xs, ( i - 1 )) );
    };
  };

def Set<A> choose<A>(Set<A> ss, Int i) = 
  case i {
    0 => EmptySet;
    _ => case ss {
      EmptySet => EmptySet;
      Insert( x, xs ) => Insert( x, choose(xs, ( i - 1 )) );
    };
  };

def Map<A, B> takeMap<A, B>(Map<A, B> mp, Int i) = 
  case i {
    0 => EmptyMap;
    _ => case mp {
      EmptyMap => EmptyMap;
      InsertAssoc( x, xs ) => InsertAssoc( x, takeMap(xs, ( i - 1 )) );
    };
  };

def Bool isAppendCommand(Command c) = 
  case c {
    SkipFile => True;
    ContinueFile => True;
    OverwriteFile => True;
    _ => False;
  };

def List<A> setAt<A>(List<A> list, A a, Int i) = 
  case list {
    Nil => Nil;
    Cons( p, l ) => case i {
      0 => Cons( a, l );
      _ => Cons( p, setAt(l, a, ( i - 1 )) );
    };
  };

def Bool setEquals<A>(Set<A> s, Set<A> t) = 
  ( ( size(s) == size(t) ) && subset(s, t) );

def Bool subset<A>(Set<A> s, Set<A> t) = 
  case t {
    EmptySet => True;
    Insert( x, xs ) => case contains(s, x) {
      True => subset(s, xs);
      False => False;
    };
  };

def Int pow(Int b, Int e) = 
  case e {
    0 => 1;
    _ => ( b * pow(b, ( e - 1 )) );
  };

[( text >= 1 )] [( result() >= 1 )] [( result() <= ( 2 * text ) )]
def List<String> split(String text, String c) = 
  case ( strlen(text) == 0 ) {
    True => Nil;
    False => split2(tailStr(text), c, Cons( headStr(text), Nil ));
  };

def List<String> split2(String text, String c, List<String> result) = 
  case result {
    Cons( h, t ) => case ( strlen(text) == 0 ) {
      True => reverse(result);
      False => let ( String hd ) = headStr(text) in case ( hd == c ) {
        True => split2(tailStr(text), c, Cons( "", result ));
        False => split2(tailStr(text), c, Cons( ( h + hd ), t ));
      };
    };
  };

def String headStr(String text) = 
  substr(text, 0, 1);

def String tailStr(String text) = 
  substr(text, 1, ( strlen(text) - 1 ));

def Bool isPrefix<A>(List<A> list1, List<A> list2) = 
  case list2 {
    Nil => True;
    Cons( l, ll ) => case list1 {
      Nil => False;
      Cons( m, mm ) => ( ( l == m ) && isPrefix(mm, ll) );
    };
  };

[( s >= 0 )] [( result() <= ( ( 2 * s ) + 1 ) )]
def List<String> stringToChar(String s) = 
  let ( Int l ) = strlen(s) in case ( l == 0 ) {
    True => Nil;
    False => Cons( headStr(s), stringToChar(tailStr(s)) );
  };

def Bool isPrefixText(String s1, String s2) = 
  isPrefix(stringToChar(s2), stringToChar(s1));

def Bool filter(String pattern, String text) = 
  isPrefixText(pattern, text);

def Set<String> filters(String pattern, Set<String> ts) = 
  case ts {
    EmptySet => EmptySet;
    Insert( l, ls ) => case filter(pattern, l) {
      True => Insert( l, filters(pattern, ls) );
      False => filters(pattern, ls);
    };
  };

def Set<DCData> modifyCPU(Set<DCData> ds, Int cpu) = 
  case ds {
    EmptySet => Insert( CPU( cpu ), EmptySet );
    Insert( x, xs ) => case x {
      CPU( _ ) => Insert( CPU( cpu ), xs );
      _ => Insert( x, modifyCPU(xs, cpu) );
    };
  };




module ReplicationSystem.Main;

export *;

import * from ReplicationSystem.Environment.DataTypes;
import * from ReplicationSystem.Environment.Files;
import * from ReplicationSystem.ReplicationSystem;
import * from ABS.StdLib;

class ReplicationSystemMain {
  [Final]
  List<Pair<String, List<Item>>> businessItems = Nil;
  [Final]
  List<Pair<String, List<Item>>> dataItems = Nil;
  [Final]
  List<Pair<String, List<Item>>> searchItems = list(Cons( Pair( "Search", list(Cons( SearchItem( "indices/search" ), Nil )) ), Nil ));
  [Final]
  Map<String, Pair<Int, Deadline>> scheduleMap = map(Cons( Pair( "Search", Pair( 0, Duration( 10 ) ) ), Nil ));
  
  Unit run(){
    List<Schedule> schedules = this.getSchedules();
    Set<ClientId> cids = this.getCids();
    Int maxJobs = this.getMaxJobs();
    Int maxUpdates = this.getMaxUpdates();
    new ReplicationSystem(maxUpdates, schedules, maxJobs, cids);
  }
  Int getMaxJobs(){
    return 7;
  }
  Int getMaxUpdates(){
    return - 1;
  }
  Map<String, Pair<Int, Deadline>> getScheduleMap(){
    return scheduleMap;
  }
  List<Schedule> getSchedules(){
    Map<String, Pair<Int, Deadline>> m = this.getScheduleMap();
    return itemMapToSchedule(Nil, m, concatenates(list(Cons( searchItems, Cons( businessItems, Cons( dataItems, Nil ) ) ))));
  }
  Set<ClientId> getCids(){
    Set<ClientId> cs = EmptySet;
    Int c = this.getNumberOfClients();
    while (( c > 0 )) {
      cs = Insert( c, cs );
      c = ( c - 1 );
    }
    return cs;
  }
  Int getNumberOfClients(){
    return 1;
  }
  }


