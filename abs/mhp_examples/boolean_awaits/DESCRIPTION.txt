-deadlock_with_loop_inside.abs
-deadlock_with_nested_loop_inside.abs

In these examples a deadlock is possible because the f.get instruction in initialize can be
executed several times but not all times are guaranteed to happen before.


-fake_deadlock_with_loop_inside.abs
-fake_deadlock_with_nested_loop_inside.abs

In these two examples, there is no deadlock because even if the instruction f.get can happen several times,
and the field assigment is also executed several times, the effect of the field assignment can only be seen
by other task after the complete method initialize is finished 
(because there is no release in the whole method). Consequently, we could guarantee that the whole method is
finished and avoid the deadlock.
Unfortunately, the poinsto analysis is imprecise and makes the field assignment effective at the end of each
iteration. That is why the tool still reports a deadlock.


-no_deadlock_with_loop_before.abs

This example illustrates a limitation of the approach. There is no deadlock because all instances of
f.get are executed before the field assignment. However, our strategy tries to guarantee that at least one
is finished (which can do without any problem) and then check that there is only one instance of that point 
(which is not true for this case).

--no_deadlock_with_loop.abs
--no_deadlock_with_loop_and_if.abs
--no_deadlock_with_nested_loop.abs
--no_deadlock_with_nested_loop_if.abs

This cases are correctly handled.



--no_deadlock_non_unique_getX.abs

Example of why a MHH seed based on a future variable does not need to be unique.

--no_deadlock_importance_of_MHPgraph.abs

Example of why it could be important to incorporate the MHF information at the level of MHP graphs and
not only at the level of points.
at the point of  f.get in B.go we can guarantee that initialize, ini1, ini2 are finished but callQ is not
unique. However, if ini1 and ini2 are finished are finished, callQ must be also finished. The MHP can
tell us that.
