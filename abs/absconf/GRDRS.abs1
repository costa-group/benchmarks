module FullReplicationSystem;
//import * from ABS.StdLib;

interface ReplicationSnapshot {
	Unit refreshSnapshot(Bool refreshSnapshot);
	
	/*
	 * Cleaning replication snapshot 
	 */
	Unit clearSnapshot();
	Int getIndexingId();
	Set<ServerReplicationItem> getItems();
	
	/*
	 * Only exists at model level
	 */
	Bool hasUpdated();
	
}

/*
 * Represents an item to be replicated to 
 * the sync clients. Global for the SyncServer
 *
 * Items could be abstracted as data type 
 * but data types cannot be modified by deltas! 
 */
interface ServerReplicationItem {
	FileEntry getContents();
	Command getCommand();
	ReplicationItemType getType();
	FileId getAbsoluteDir();
	 Unit refresh();
	 Unit cleanup();
}

class SyncServerAcceptorImpl([Near] InternalServer server) 
implements SyncServerAcceptor {
	
	// A flag representing com.fredhopper.replication.server.SyncServerAcceptorThread.waitForResumingSignal
	// A flag representing com.fredhopper.replication.server.SyncServerAcceptorThread.acceptingConnections
	Bool accept = True;

	Int threads = 0; // for debugging
	
	// Return a null thread if server is/has been shutting down
	ConnectionThread getConnection(ClientJob job) {
		ConnectionThread thread = null;
		
		// Shutdown flag	
		InternalServer n = this.server; 
		Bool shutdown = n.isShutdownRequested();
		if (~ shutdown) {
			await accept;
			thread = new ConnectionThreadImpl(job,server,threads);
			thread!run();
			threads = threads + 1; // for debugging
		} 
		
		return thread;
	}
	
	Bool isAcceptingConnection() {
		return accept;
	}
	
	Unit suspendConnection() {
		accept = False;
	}
	
	Unit resumingConnection() {
		accept = True;
	}
}





// CSP model ClientReplicationJob(n)
// Java class com.fredhopper.replication.client.ClientReplicationJob
class ClientJobImpl([Far] InternalClient client, JobType job) 
implements ClientJob {
	
	Command command = EndSnapShot;
	Bool hasSchedule = False;
	
	// A flag to see if new local job should start
	Bool newJob = False;
	
	ConnectionThread thread = null;
	[Far] ClientDataBase db;
	
	ConnectionThread getConnectionThread() {
		Fut<ServerAcceptor> fs = client!getAcceptor();
		ServerAcceptor acceptor = fs.get;
		
		// Acquire a connection
		Fut<ConnectionThread> t = acceptor!getConnection(this); await t?;
		return t.get;
	}
	
	Unit setDb() {
		Fut<ClientDataBase> fd = client!getClientDataBase();
		this.db = fd.get;
	}
	
	// starts a replication job
	Unit scheduleNewJob() {
		await newJob;
		Runnable r=new local ClientJobImpl(this.client,Replication);
		r!run();
	}
	
	Unit run() {
		// set data base
		this.setDb();
	
		// Acquire a connection
		this.thread = this.getConnectionThread();
		if (thread != null) {
			// Connection successful!
			Fut<Unit> unit;
			if (this.job == Boot) {
				this.becomeState(Booting);
				
				this.thread!command(ListSchedule);
				await hasSchedule == True;
				
				//establish the next schedule triggers!
				this!scheduleNewJob();
				
			} else {
				this.becomeState(WorkOnReplicate);
				
				this.thread!command(SearchSchedule);
				await hasSchedule == True;
				
				//establish the next schedule triggers!
				this!scheduleNewJob();
				
				// wait for current job to start then end
				await command == StartSnapShot;
				await command == EndSnapShot;
			}
				
			this.becomeState(WaitToReplicate);
			
			unit = this.client!incrementJob();
			unit.get;
			
			//allow next job to proceed
			newJob = True;
			
		} else {
			// Connection unsuccessful! Perform shutdown 
			this.shutDownClient();
		}
	}
	
	Unit becomeState(State state) {
		Fut<Unit> unit = this.client!becomesState(state); unit.get;
	}
	
	ClientId forClient() {
		Fut<ClientId> fut = client!getId();
		return fut.get;
	}
	
	Unit shutDownClient() {
		Fut<Unit> unit = client!requestShutDown(); unit.get;
		unit = client!becomesState(End); unit.get;
	}
	
	Bool registerReplicationItems(CheckPoint checkpoint) {
		Fut<Bool> reg = db!prepareReplicationItem(checkpoint);
		return reg.get;
	}
	
	Bool hasFile(FileId id) {
		Fut<Bool> he = db!hasFile(id); await he?;
		return he.get;
	}
	
	
	  //CSP model Register
	  //com.fredhopper.replication.client.ClientReplicationJob.receiveItemFragment(DataInputStream, int, ClientReplicationItem)
	 
	Maybe<FileSize> processFile(FileId id) {
		Maybe<FileSize> result = Nothing;
		Fut<Set<FileId>> fs = db!listFiles();
		Set<FileId> fids = fs.get;
		if (contains(fids,id)) {
			Bool he = this.hasFile(id);
			if (he) {
				Fut<FileContent> contentf = db!getContent(id); await contentf?;
				FileContent content = contentf.get; 
				if (isFile(content)) {
					FileSize size = content(content);
					result = Just(size);				
				}
			}
		}
		return result;
	}  
	
	Unit overwrite(File file) {
		FileId id = fst(file);
		FileSize size = fileContent(file);
		Fut<Unit> u = db!updateFile(id,size); await u?;
	}
	
	Unit continue(File file) {
		FileId id = fst(file);
		FileSize size = fileContent(file);
		
		Bool he = this.hasFile(id);
		FileSize fsize = 0;
		if (he) {
			Fut<FileContent> s = db!getContent(fst(file)); await s?;
			FileContent c = s.get;
			fsize = content(c);		
		}
		
		size = size + fsize;
		Fut<Unit> u = db!updateFile(id,size); await u?;
	}
	
	Unit processContent(File file) {
		await isAppendCommand(command);
		if (command == SkipFile) {
			skip;
		} else if (command == OverwriteFile) {
			this.overwrite(file);
		} else if (command == ContinueFile) {
 			this.continue(file);
		}
	}  
	
	 Unit command(Command c) { 
		command = c; 
	}
	
	Unit receiveSchedule() { hasSchedule = True; }
	
	Int getId() { return 1; }
} 

// Implementation of SyncClient 
// Java class com.fredhopper.application.SyncClient
[COG] class SyncClientImpl(ClientId id) 
implements InternalClient, ClientConnector {
	
	Map<State,Set<State>> machine = EmptyMap;
	
	ServerAcceptor acceptor = null;
	ClientDataBase db = null;

	State state = Start;
	Int jobCount = 0;
	Bool shutDown = False;
	
	{
		
		// Defines possible transitions
		//Pair<State,Set<State>> start = 			 Pair(Start, 			set[WaitToBoot]);
		//Pair<State,Set<State>> waitToBoot = 	 Pair(WaitToBoot, 		set[Booting,End]);
		//Pair<State,Set<State>> booting =		 Pair(Booting, 			set[WaitToBoot,WaitToReplicate,End]);
		//Pair<State,Set<State>> waitToReplicate = Pair(WaitToReplicate, 	set[WaitToBoot,WorkOnReplicate,End]);
		//Pair<State,Set<State>> workOnReplicate = Pair(WorkOnReplicate,	set[WaitToBoot,WaitToReplicate,End]);
		
		// Creates states machine
		//this.machine = map[start,waitToBoot,booting,waitToReplicate,workOnReplicate];
		
		// initialize the client side data base
		//this.db = new local DataBaseImpl(EmptyMap);
		
	}
	
	ClientId getId() {
		return this.id;
	}
		
	Bool isShutdownRequested() {
		return this.shutDown;
	}
	
	Unit requestShutDown() {
		this.shutDown = True;
	}
		
	Unit incrementJob() {
		jobCount = jobCount + 1;
	}
	
	ServerAcceptor getAcceptor() {
		ServerAcceptor a = acceptor;
		return a;
	}
	
	Unit run() {
		// Makes a transition
		this.becomesState(WaitToBoot);
		
		// wait for acceptor to be ready
		await acceptor != null;
		
		this.incrementJob();
		
		// starts a boot job
		Runnable r=new ClientJobImpl(this,Boot);
		r!run();
	}
	
	ClientDataBase getClientDataBase() {
		ClientDataBase c = db;
		return c;
	}
	
	DataBase getDataBase() {
		DataBase d = db;	
		return d;
	}
	
	Unit becomesState(State state) {
		//assert contains(lookup(machine,this.state),state);
		this.state = state;	
	}
	
	Unit setAcceptor([Far] ServerAcceptor acc) {
		this.acceptor = acc;
	}
		
}

[COG] class ConnectionThreadImpl(
		[Far] ClientJob job, 
		[Far] InternalServer server, 
		Int id) implements ConnectionThread {

	SyncServerClientCoordinator coord;
	Maybe<Command> cmd = Nothing;
	
	Unit run() {
		Fut<SyncServerClientCoordinator> c = server!getCoordinator(); await c?;
		this.coord = c.get;
		
		// register and refresh snapshot
		Fut<Unit> rp = this.coord!startReplicationUpdate(this); await rp?;
		
		// wait for client's command
		await this.cmd != Nothing;
		
		// Send schedules
		rp = this.job!receiveSchedule(); await rp?;
		
		if (cmd != Just(ListSchedule)) {
	
			// Get replication items
			Fut<ReplicationSnapshot> sp = this.server!getReplicationSnapshot();
			ReplicationSnapshot snapshot = sp.get;
			
			Fut<CheckPoint> cpf = snapshot!getIndexingId(); await cpf?;
			CheckPoint cp = cpf.get;
			
			Fut<Bool> b = job!registerReplicationItems(cp); await b?;
			Bool register = b.get;
			
			Set<Set<File>> filesets = EmptySet;
			if (register) {
				Fut<Set<ServerReplicationItem>> nis = snapshot!getItems(); await nis?;
				Set<ServerReplicationItem> newitems = nis.get;
				filesets = this.registerItems(newitems);
			}
			
			// start snapshot
			rp = this.job!command(StartSnapShot); await rp?;
			
			while (hasNext(filesets)) {
				Pair<Set<Set<File>>,Set<File>> nfs = next(filesets);
				filesets = fst(nfs);
				Set<File> fileset = snd(nfs); 
				this.transferItems(fileset);
			}
			
			// before ending snapshot replication
			// tell server this client has completed its session
			ClientId cid = this.forClient();
			
			// this is superfluous call! (waiting period)
			rp = this.server!debug(); await rp?;
			
			rp = this.coord!finishClient(cid); await rp?;
			
			// end snapshot		
			rp = this.job!command(EndSnapShot); await rp?;
		
		}
		
		rp = this.coord!finishReplicationUpdate(this); await rp?;
				
	}
	
	ClientId forClient() {
		Fut<ClientId> id = job!forClient();
		ClientId id2 = id.get;
		return id2;
	}
	
	 Unit command(Command c) { 
		this.cmd = Just(c); 
	}
	
	
	 // Register replication items with client 
	 // Returns a set of files to be replicated
	 
	Set<Set<File>> registerItems(Set<ServerReplicationItem> items) {
		Set<Set<File>> regs = EmptySet;	
	
		//iterate over possible check points
		while (hasNext(items)) {
			Pair<Set<ServerReplicationItem>,ServerReplicationItem> nis = next(items);
			items = fst(nis);
			ServerReplicationItem item = snd(nis);

			// For now convert to a set
			// will convert it into directory
			Fut<FileEntry> entryf = item!getContents(); await entryf?;
			FileEntry entry = entryf.get;
			
			Set<File> result = EmptySet;
			Set<FileId> ids = getFileIdFromEntries1(entry);
			while (hasNext(ids)) {
				Pair<Set<FileId>,FileId> nids = next(ids);
				FileId id = snd(nids);
				Maybe<FileContent> content = getFromEntry(entry,id);
				result = Insert(Pair(id,fromJust(content)),result);
				ids = fst(nids);
			}
			
			regs = Insert(result,regs);
		}
		
		return regs;
	}
	
	Unit transferItems(Set<File> fileset) {
		while (hasNext(fileset)) {
			Pair<Set<File>,File> nf = next(fileset); 
			fileset = fst(nf);
			File file = snd(nf);
			FileSize tsize = fileContent(file);
			
			Fut<Unit> rp = job!command(AppendSearchFile); await rp?;
			Fut<Maybe<FileSize>> fs = job!processFile(fst(file)); await fs?;
			Maybe<FileSize> content = fs.get;
			
			FileSize size = 0;
			if (isJust(content)) { 
				size = fromJust(content);
			}
			
			if (size > tsize) {
				rp = job!command(OverwriteFile);
				await rp?;
				rp = job!processContent(file);
				await rp?;
			} else {
				// find out how much is still need to be replicated
				if (tsize - size > 0) {
					rp = job!command(ContinueFile);
					await rp?;
					
					file = file(fst(file),tsize - size);
					rp = job!processContent(file);
					await rp?;
				} else {
					rp = job!command(SkipFile);
					await rp?;
				}
			}

		}
		Fut<Unit> rp = job!command(EndSearchFile); await rp?;
	}
}

// CSP model CoordinatorProcess
// Java class com.fredhopper.replication.server.SyncServerClientCoordinator
[COG] class SyncServerClientCoordinatorImpl(
		[Far] SyncServer server,
		[Far] ReplicationSnapshot snapshot,
		Set<ClientId> clients) implements SyncServerClientCoordinator {
	
	Int count = 0;
	Maybe<CheckPoint> cps = Nothing;
	
	Bool shutDown = False;
	
	// Mimic internal choice
	Bool internal = False;
	
	SyncServerAcceptor acceptor = null;
	Set<ConnectionThread> threads = EmptySet;
	
	// Keep track of current list of clients (used for invariant checking)
	Set<ClientId> currentClients = EmptySet;
	
	//trace of clients activity
	//initialise with empty trace
	List<List<ClientId>> traces = Cons(Nil,Nil);
	
	Unit process() {
		Fut<Unit> unit;
	
		// get SyncServerAcceptor
		Fut<SyncServerAcceptor> fs = this.server!getAcceptor(); await fs?;
		this.acceptor = fs.get;
		
		Bool shutdown = this.isServerShutdownRequested();
		while (~shutdown) {
			//try polling on the return boolean value
			Fut<Bool> fd = acceptor!isAcceptingConnection(); await fd?;
			Bool accept = fd.get;
			
			// There is a consideration about how long 
			// a worker should have been working
			// This is abstracted in this model and 
			// so we use a flag to model this.
			if (accept) {
				if (~ emptySet(threads) && internal) {
					unit = this.acceptor!suspendConnection(); await unit?;
					this.internal = False;
				} else {
					this.internal = True;
				}
			} else {
				if (emptySet(threads)) {
					unit = this.acceptor!resumingConnection(); await unit?;
				}
			}
			shutdown = this.isServerShutdownRequested();
		}
		
		// Shutdown sequence
		await threads == EmptySet;
		unit = this.acceptor!resumingConnection(); await unit?;
	}
	
	Bool isServerShutdownRequested() {
		Fut<Bool> fd = this.server!isShutdownRequested(); await fd?;
		return fd.get;
	}
	
	// Setting up a replication session
	Unit startReplicationUpdate(ConnectionThread thread) {
		this.threads = Insert(thread,this.threads);
		if (size(this.threads) == 1) {
			this.refreshSnapShot();
		}
	}
	
	// Tidy up after a replication session
	Unit finishReplicationUpdate(ConnectionThread thread) {
		if (contains(this.threads,thread)) {
			if (size(this.threads) == 1) {
				Fut<Unit> unit = this.snapshot!clearSnapshot(); unit.get;
			}
			this.threads = remove(this.threads,thread);
		}
	}
	
	Unit refreshSnapShot() {
		count = count + 1; //for debug

		Bool makeChange = this.isNotWaitingForMoreClient();
		
		// advance check point only after data 
		// has been replicated to all clients
		Fut<Unit> unit = this.snapshot!refreshSnapshot(makeChange); unit.get;
		
		// check point to see if any items has been reloaded
		CheckPoint cp = this.getCurrentCheckPoint();
		
		// check point to see if an update has happened
		Fut<Bool> rf = this.snapshot!hasUpdated();
		Bool up = rf.get;
		this.shutDown = ~up;
		
		//reset the current client lists 
		//if refresh is successful and is not waiting
		//for more clients.
		if (makeChange) {
			if (this.cps == Nothing || cp > fromJust(this.cps)) {
				this.cps = Just(cp);
				this.traces = appendright(this.traces,Nil);
			}
			
			if (~this.shutDown) {
				this.currentClients = this.clients;
			} else {
				unit = this.server!requestShutDown(); unit.get;
			}
		}
		
	}
	
	ClientId getClientId([Far] ConnectionThread thread) {
		Fut<ClientId> fid = thread!forClient(); 
		return fid.get;
	}
	
	Unit removeClient(ConnectionThread thread) {
		ClientId id = this.getClientId(thread);
		this.currentClients = remove(this.currentClients,id);
	}
	
	Unit addClient(ConnectionThread thread) {
		ClientId id = this.getClientId(thread);
		//assert ~contains(this.currentClients,id);
		this.currentClients= Insert(id,this.currentClients);
	}
	
	
 	 // We need to introduce a mechanism to determine
	 // the number of SyncClients that will be connected to 
	 // this implementation of the SyncServer
	 
	 // Note that this method is not exposed through any interface
	 
	Bool isNotWaitingForMoreClient() {
		return this.currentClients == EmptySet;
	}
	
	CheckPoint getCurrentCheckPoint() {
		Fut<CheckPoint> cf = this.snapshot!getIndexingId();
		return cf.get;
	}
	
	
	 // Indicate client specified by cid is finished its 
	 // replication session 
	 
	Unit finishClient(ClientId cid) {
		CheckPoint cp = this.getCurrentCheckPoint();
		this.currentClients = remove(this.currentClients,cid);
		//assert length(this.traces) > cp - 1;
		this.traces = setAt(this.traces,appendright(nth(this.traces,cp-1),cid),cp-1);
	}
	
	Int getCount() {
		return this.count;
	}
} 


 // A simple model of a database mimicking 
 // a sequence of updates of files
 
[Plain] class DataBaseImpl(Map<CheckPoint, Map<FileId,FileContent>> db) 
implements ServerDataBase, ClientDataBase {
	
	Int count = 0; //for debug
	
	CheckPoint ccp = -1;
	Set<CheckPoint> checkPoints = keys(db);
	
	// Begin with the root location (id = 0)
	Directory rooot = rootDir();

	// ClientDataBase
	 Bool prepareReplicationItem(CheckPoint p) {
		Bool result = False;
		if (~ contains(checkPoints,p)) {
			checkPoints = Insert(p,checkPoints);
			ccp = p;
			result = True;
		}
		return result;
	}
	
	 Bool advancedCheckPoint() {
		Bool result = False;
		if (hasNext(checkPoints)) {
			Pair<Set<CheckPoint>,CheckPoint> nt = next(checkPoints);
			checkPoints = fst(nt);
			ccp = snd(nt);
			result = True;
		}
		return result;
	}
	
	 Bool refresh(Bool update) {
		count = count + 1;
		Bool more = False;
		
		// advanced to the next check point;
		// only if update if required
		if (update) {
			more = this.advancedCheckPoint();
		}
		
		// if update is not required 
		// then update the filestore of the current checkpoint
		// else update the filestore of the next checkpoint
		if (~update || more) {
			Map<FileId,FileContent> updates = lookup(db,ccp);
			this.rooot = updateDirWithContents(this.rooot,updates);
		}
		
		return (~update || more);
	}
	
	// Returns 0 if file not found.
	 FileContent getContent(FileId fId) {
		Maybe<FileContent> result = Nothing;  
		if (fId == rroot()) {
			result = Just(getFileContent(Right(rooot)));
		} else {
			result = getFromEntryIn(rooot,fId);
		}
		return fromJust(result);
	}
	
	 Bool hasFile(FileId fId) {
		return hasEntriesIn(rooot,fId);
	}
  
	 Map<FileId,FileContent> checkPointFiles() {
		return lookupDefault(db,ccp,EmptyMap);
	}
	
	// Updates file store
	// ClientDataBase
	 Unit updateFile(FileId fId, FileSize size) {
		rooot = updateDirWithFile(rooot,file(fId,size));
	}
	
	 Set<FileId> listCheckPointFiles() {
		Map<FileId,FileContent> checkPointFiles = this.checkPointFiles();
		return keys(checkPointFiles);
	}
	
	 Set<FileId> listFiles() {
		Set<FileId> nieuw = getFileIdFromDir(rooot);
		return nieuw;
	}
}

data State = 
	Start | WaitToBoot | Booting | 
	WaitToReplicate| WorkOnReplicate | End;
	
data Command =
	StartSnapShot | EndSnapShot | ListSchedule | 
	SearchSchedule | EndSearchFile | AppendSearchFile |
	ReceivePatternFile | 
	SkipFile | ContinueFile | OverwriteFile;
	
data JobType = Replication | Boot;

data ReplicationItemType =
	SearchReplicationDirectory | LogReplicationItem | ReplicationFilePattern;

type ClientId = Int;
	
// CSP set CheckPoint
// Java class com.fredhopper.search.fred.Checkpoint
// For Java method com.fredhopper.replication.server.item.SearchReplicationDirectory.isValid(String, long)
type CheckPoint = Int;

// Functions on set of pairs
def Set<A> fsts<A, B>(Set<Pair<A, B>> ps) =
  case ps {
  	EmptySet => EmptySet;
  	Insert(x,xs) => Insert(fst(x),fsts(xs));
  };
  
def Set<B> snds<A, B>(Set<Pair<A, B>> ps) =
  case ps {
  	EmptySet => EmptySet;
  	Insert(x,xs) => Insert(snd(x),snds(xs));
  };
  
// Functions on set
def Set<A> myunion<A>(Set<A> set1, Set<A> set2) =
  	case set1 { 
  		EmptySet => set2; 
  		Insert(s, ss) => Insert(s, myunion(ss, remove(set2,s)));
  	};
  
// Functions on data Command
def Bool isAppendCommand(Command c) = 
	case c {
		SkipFile => True;
		ContinueFile => True;
		OverwriteFile => True;
		_ => False;
	};
	
// Insert 'a' at position i of list. 
def List<A> setAt<A>(List<A> list, A a, Int i) =
	case list {
		Nil => Nil;
		Cons(p,l) => 
			case i {
				0 => Cons(a,l);
				_ => Cons(p,setAt(l,a,i-1));
			 };
	};
	
def Bool setEquals<A>(Set<A> s, Set<A> t) = size(s) == size(t) && subset(s,t);

// t is a subset of s
def Bool subset<A>(Set<A> s, Set<A> t) = 
	case t {
		EmptySet => True;
		Insert(x,xs) => contains(s,x) && subset(s,xs);
	};

// 	
def Int pow(Int b, Int e) =
	case e {
		0 => 1;
		_ => b * pow(b,e-1); 
	};


// String operations
// c must have length 1 currently
// COSTABS ANNOTATION
[text >= 1][result() >= 1][result() <= 2*text]
def List<String> split(String text, String c) = 
	case strlen(text) == 0 {
		True => Nil;
		False => split2(tailStr(text),c,Cons(headStr(text),Nil)); 
	};
	
def List<String> split2(String text, String c, List<String> result) =
    case result {
      Cons(h,t) =>
	case strlen(text) == 0 {
		True => reverse(result);
		False => 
			let (String hd) = headStr(text) in
			case hd == c {
				True => split2(tailStr(text),c,Cons("",result));
				False => split2(tailStr(text),c,Cons(h+ hd,t));
			};
	};
    };
    	
def String headStr(String text) = substr(text,0,1);
def String tailStr(String text) = substr(text,1,strlen(text)-1);

// if list2 is a prefix of list1 
def Bool isPrefix<A>(List<A> list1, List<A> list2) =
	case list2 {
		Nil => True;
		Cons(l,ll) => 
			case list1 {
				Nil => False;
				Cons(m,mm) => (l == m) && isPrefix(mm,ll);
			};
	};
	
// COSTABS ANNOTATION
[s >= 0][result() <= 2*s+1]
def List<String> stringToChar(String s) =
	let (Int l) = strlen(s) in
	case l == 0 {
		True => Nil;
		False => Cons(headStr(s),stringToChar(tailStr(s)));
	};
	
def Bool isPrefixText(String s1, String s2) = isPrefix(stringToChar(s2),stringToChar(s1));

def Bool filter(String pattern, String text) = isPrefixText(pattern,text);

// filters a set of strings against some pattern
def Set<String> filters(String pattern, Set<String> ts) =
	case ts {
		EmptySet => EmptySet;
		Insert(l,ls) => 
			case filter(pattern,l) {
				True => Insert(l,filters(pattern,ls));
				False => filters(pattern,ls);
			};
	};

[TypeAnnotation]
data VarType = Adds | Modifies;


// test data 
type TestData = Map<CheckPoint,Map<FileId,FileContent>>;

// CSP set FileId 
// Used for identifying the file to be replicated
type FileId = String;

// CSP set FileSize
// Java method java.io.File.length()
// Used for identifying the state of the client-side file 
type FileSize = Int;

// CSP name type File
type File = Pair<FileId,FileContent>;
type Directory = Pair<FileId,FileContent>;

// CSP name type Item
// Java class com.fredhopper.replication.server.item.ServerReplicationItem
type ReplicationItem = Pair<CheckPoint,Set<File>>;

// A File system structure
// internally file entry is organised hierarhically
// e.g. file 123 is organised 1/2/123 where 1 and 2 are directories
// default root directory id is 0 
// This will be extended once we allowed file ids as strings like "12/34/56".
type FileEntry = Map<FileId,FileContent>;

// Java com.fredhopper.replication.server.SyncServerSchedule
data Schedule = 
	  SearchItem(FileId) | //top level directory
	  FileItem(FileId,String) | //top level directory, pattern, checkpoint
	  LogItem(FileId); //for now log item is the same as search item

def Bool isSearchItem(Schedule s) = case s { SearchItem(_) => True; _ => False; };
def Bool isFileItem(Schedule s) = case s { FileItem(_,_) => True; _ => False; };
def Bool isLogItem(Schedule s) = case s { LogItem(_) => True; _ => False; };

def Either<FileId,Pair<FileId,String>> item(Schedule s) = 
	case s { 
		SearchItem(i) => Left(i); 
		FileItem(i,r) => Right(Pair(i,r));
		LogItem(i) => Left(i); 
	};

// a set of schedules
type ServerSchedule = Set<Schedule>;

// seems cannot use type synonym Either
data FileContent = Content(FileSize) | Entries(FileEntry); 

// if id1 is an ancester of id2
def Bool isAncester(FileId id1, FileId id2) = 
	isPrefix(deroot(split(id2,fileSep())),deroot(split(id1,fileSep()))); 
	 
def List<String> deroot(List<String> path) =
	let (FileId r) = rroot() in case path { Cons(r,ps) => ps; _ => path; };

def File file(FileId i, FileSize s) = Pair(i,Content(s));
def Directory rootDir() = emptyDir(rroot());
def Directory emptyDir(FileId i) = Pair(i,Entries(EmptyMap));
def Directory dir(FileId i, FileEntry e) = Pair(i,Entries(e));

def String fileSep() = "/";
def FileId rroot() = "root";
def Bool isFile(FileContent c) = case c { Content(_) => True; _ => False; };
def Bool isDirectory(FileContent c) = ~isFile(c);

// partial
def FileSize content(FileContent c) = case c { Content(s) => s; };
def FileSize fileContent(File f) = content(snd(f));

// partial
def FileEntry entries(FileContent c) = case c { Entries(fs) => fs; };
def FileEntry dirContent(Directory f) = entries(snd(f));
	
def FileId getFileId(Either<File,Directory> f) =
	case f {
		Left(Pair(id,_)) => id;
		Right(Pair(id,_)) => id;
	};

def FileContent getFileContent(Either<File,Directory> f) =
	case f {
		Left(Pair(_,s)) => s;
		Right(Pair(_,fs)) => fs;
	};
	
def Either<File,Directory> makeContent(Pair<FileId,FileContent> content) =
	case isFile(snd(content)) {
		True => Left(content);
		False => Right(content);
	};

// given a/b and c returns a/b/c
def FileId makePath(FileId dir, FileId f) = dir + fileSep() + f;
def FileId makePaths(List<String> fs) = 
	case fs {
		Nil => "";
		Cons(f,Nil) => f;
		Cons(f,gs) => f + fileSep() + makePaths(gs);
	};

// given a/b/c returns (a/b,c)
def Pair<FileId,FileId> splitFileId(FileId f) = Pair(dirName(f),fileName(f));

// given a/b/c returns c
def FileId fileName(FileId f) = head(reverse(split(f,fileSep())));

// given a/b/c returns a/b
def FileId dirName(FileId f) = makePaths(reverse(tail(reverse(split(f,fileSep())))));	

// get fully qualified file ids from the suppied directory recursively
def Set<FileId> getFileIdFromDir(Directory d) = 
	case snd(d) { 
		Entries(e) => 
			case fst(d) == rroot() {
				True => getFileIdFromEntries1(e);
				False => getFileIdFromEntries(fst(d),e);
			};
	};
	
def Set<FileId> getFileIdFromEntries1(FileEntry fe) =
	case fe {
		EmptyMap => EmptySet;
		InsertAssoc(Pair(i,c),fs) => 
			case isFile(c) {
				True => Insert(i,getFileIdFromEntries1(fs));
				False => myunion(getFileIdFromEntries(i,entries(c)),getFileIdFromEntries1(fs));
			};
	};
	
def Set<FileId> getFileIdFromEntries(FileId id, FileEntry fe) =
	case fe {
		EmptyMap => EmptySet;
		InsertAssoc(Pair(i,c),fs) => 
			case isFile(c) {
				True => Insert(makePath(id,i),getFileIdFromEntries(id,fs));
				False => myunion(getFileIdFromEntries(makePath(id,i),entries(c)),getFileIdFromEntries(id,fs));
			};
	};
	
def Bool hasEntriesIn(Directory d, FileId id) = case snd(d) { Entries(e) => hasEntry(e,id); };
def Bool hasEntry(FileEntry f, FileId id) = isJust(findFromEntry(f,id));

// find either a file or a directory (if it exists) given
// the file name (suffix of a fully qualified path)
def Maybe<Either<File,Directory>> findFromEntryIn(Directory d, FileId id) = 
	case snd(d) { Entries(e) => findFromEntry(e,id); };

// find either a file or a directory (if it exists) given
// the file name (suffix of a fully qualified path)
def Maybe<Either<File,Directory>> findFromEntry(FileEntry f, FileId id) =
	case contains(keys(f),id) {
		True =>
			case lookup(f,id) {
				Content(s) => makeMaybeEitherValue(True,id,Content(s)); // leaf
				Entries(e) => makeMaybeEitherValue(False,id,Entries(e)); // leaf
			};
		False => 
			case f {
				InsertAssoc(Pair(i,Content(_)),fm) => findFromEntry(fm,id);
				InsertAssoc(Pair(i,Entries(g)),fm) => 
						case findFromEntry(g,id) {
							Nothing => findFromEntry(fm,id); //next path
							r => qualify(r,i);
						};
				EmptyMap => Nothing; // end of listing
			};	 
	};
	
// prefix id of 'r' with 'path'
def Maybe<Either<File,Directory>> qualify(Maybe<Either<File,Directory>> r, FileId path) =
	case r {
		Just(h) =>
			let (FileId hi) = makePath(path,getFileId(h)) in
			let (FileContent hc) = getFileContent(h) in
			case h {
				Left(_) => makeMaybeEitherValue(True,hi,hc);
				Right(_) => makeMaybeEitherValue(False,hi,hc);
			}; 
		Nothing => Nothing;
	};
	
def Maybe<Either<File,Directory>> makeMaybeEitherValue(Bool isfile, FileId id, FileContent c) =
	case isfile {
		True => Just(Left(Pair(id,c)));
		_ => Just(Right(Pair(id,c)));
	};
	
def Bool hasQualifiedEntriesIn(Directory d, FileId qualified) = 
	case snd(d) { Entries(e) => hasQualifiedEntry(e,qualified); };
	
def Bool hasQualifiedEntry(FileEntry f, FileId qualified) = isJust(getFromEntry(f,qualified));

[cost == 1]
def Maybe<FileContent> getFromEntryIn(Directory d, FileId qualified) = 
	case snd(d) { 
		Entries(e) => 
			case fst(d) == rroot() {
				True => getFromEntry(e,qualified); //root id '0' is disregard
				_ => getFromEntry(InsertAssoc(d,EmptyMap),qualified); 
			};
	};

// get the content (if it exists) from a fully qualified path
def Maybe<FileContent> getFromEntry(FileEntry entry, FileId qualified) = 
	let (List<String> paths) = split(qualified,fileSep()) in
	case length(paths) > 0 {
		True => 
			case contains(keys(entry),head(paths)) {
				True => 
					let (FileContent cc) = lookup(entry,head(paths)) in
					case length(tail(paths)) {
						0 => Just(cc); // at node
						_ => case cc {
								// qualified is of form 'a/b/...' 
								// but at this level 'a' is a file and not a directory
								Content(_) => Nothing; 
								// else we are on the right track
								// go to the subdirectory
								Entries(e) => getFromEntry(e,makePaths(tail(paths)));
							};  
					};
				False => Nothing; //not found
			};
		False => Nothing; 
	};
	
def Directory updateDirWithContent(Directory d, FileId i, FileContent c) = updateDirWith(d,makeContent(Pair(i,c)));
def Directory updateDirWithContents(Directory d, Map<FileId,FileContent> contents) =
	case contents {
		EmptyMap => d;
		InsertAssoc(Pair(i,c),cs) => updateDirWithContents(updateDirWithContent(d,i,c),cs);
	};

// Update a directory with a file
def Directory updateDirWithFile(Directory d, File f) = updateDirWith(d,Left(f));

// Update a directory with a directory
def Directory updateDirWithDir(Directory d, Directory f) = updateDirWith(d,Right(f));

// Update a directory with either a directory or a file
[d >= 0][f>=0][result() >=0][result() <= d+2*f+1]
def Directory updateDirWith(Directory d, Either<File,Directory> f) = case snd(d) { Entries(e) => Pair(fst(d),Entries(updateFile(e,f))); };

def FileEntry updateFile(FileEntry fe, Either<File,Directory> f) = 
	updateFile1(fe,getFileContent(f),deroot(split(getFileId(f),fileSep())));
	
def FileEntry updateFile1(FileEntry fe, FileContent c, List<String> path) =
	case path {
		Nil => fe;
		Cons(p,Nil) => put(fe,p,c);
		Cons(p,ps) =>
			case contains(keys(fe),p) {
				True => 
					case lookup(fe,p) {
						Entries(dc) => put(fe,p,Entries(updateFile1(dc,c,ps))); //dir
						_ => put(fe,p,create(ps,c));  //file 
					};
				False => put(fe,p,create(ps,c));
			}; 
	}; 

def FileContent create(List<String> path, FileContent c) =
	case c {
		Content(s) => 
			case path {
				Cons(p,Nil) => Entries(InsertAssoc(Pair(p,c),EmptyMap));
				Cons(p,ps) => Entries(InsertAssoc(Pair(p,create(ps,c)),EmptyMap));
			};
		_ => c;
	};	

//{
//	List<String> l1 = split("4/5/6",fileSep());
//	Int t1 = length(tail(l1));
//	List<String> l2 = split("4",fileSep());
//	Int t2 = length(tail(l2));
//	Directory root = emptyDir(rroot());
//	File f1 = file("1",2);
//	File f2 = file("2/3",4);
//	File f3 = file("4/5/6",6);
//	root = updateDirWithFile(updateDirWithFile(updateDirWithFile(root,f1),f2),f3);
//	Maybe<FileContent> c1 = getFromEntryIn(root,fst(f1));
//	Maybe<FileContent> c2 = getFromEntryIn(root,fst(f2));
//	Maybe<FileContent> c3 = getFromEntryIn(root,fst(f3));
//	Maybe<Either<File,Directory>> c4 = findFromEntryIn(root,"1");
//	Maybe<Either<File,Directory>> c5 = findFromEntryIn(root,"3");
//	Maybe<Either<File,Directory>> c6 = findFromEntryIn(root,"5");
//	Set<FileId> ids = getFileIdFromDir(root);
//}


interface Client extends Node {
	ClientDataBase getClientDataBase();
}

interface ClientConnector extends Client,Runnable {
	Unit setAcceptor(ServerAcceptor acceptor);
}

// CSP model SyncClient(n)
// Java class com.fredhopper.application.SyncClient
interface SyncClient extends Client,Runnable {
	[Far] ServerAcceptor getAcceptor();
	Unit becomesState(State state);
	Unit incrementJob();
}

interface InternalClient extends SyncClient {
	
	ClientId getId();
}

interface ConcurrentInternalClient extends InternalClient {
	Bool canGoTo(State state);
}

// Java class com.fredhopper.replication.client.ClientReplicationJob
// Java class com.fredhopper.replication.client.ClientBootJob
interface ClientJob extends Worker  {
	Bool registerReplicationItems(CheckPoint checkpoint);
	
	
	 //CSP model ProcessCommand'
	// com.fredhopper.replication.client.ClientReplicationJob.receiveItemFragment(DataInputStream, int, ClientReplicationItem)
	 
	Maybe<FileSize> processFile(FileId id);
	Unit processContent(File file);
	Unit receiveSchedule();
}



// Tester
interface Tester extends Runnable{ }

// Common Interfaces
interface Commandee { 
	 Unit command(Command command);
}

interface Worker extends Commandee,Runnable {
		
	  //Existing java implementation does not have client id
	  //the notion of an identifier for each client is required
	  //since the ABS model should guarantee data
	  //consistency as well as deadlock freedom
	 
	ClientId forClient();
}

// One can shut down a node or ask if the node has been shut down.
// Both client and server are nodes
interface Node {
	DataBase getDataBase();
	Bool isShutdownRequested();
	Unit requestShutDown();
}


// Common operations to all data base:
// 1. get the file size (content) of a file (id)
// 2. list all files in the file store 
 
interface DataBase {
 	 FileContent getContent(FileId fId);
 	 Bool hasFile(FileId fId);
  	 Set<FileId> listFiles();
}


interface ServerDataBase extends DataBase {
  	 Bool refresh(Bool updateFileStore);
  	 Set<FileId> listCheckPointFiles();
}


interface ClientDataBase extends DataBase {
  	 Bool prepareReplicationItem(CheckPoint cp);
  	 Unit updateFile(FileId fId, FileSize size);
}




// CSP model CoordinatorProcess
// Java class com.fredhopper.replication.server.SyncServerClientCoordinator
interface SyncServerClientCoordinator { 
	Unit process();
	Unit startReplicationUpdate(ConnectionThread worker);
	Unit finishReplicationUpdate(ConnectionThread worker);

	
	 // Indicate client specified by cid is finished its 
	 // replication session 
	 	
	Unit finishClient(ClientId cid);
}

interface InternalCoordinator {
	Unit process();
}

// CSP model AcceptorThreadRun(t)
// Java class com.fredhopper.replication.server.SyncServerAcceptorThread
interface ServerAcceptor {
	[Far] ConnectionThread getConnection(ClientJob job);
}

interface SyncServerAcceptor extends ServerAcceptor {
	Bool isAcceptingConnection();
	Unit suspendConnection();
	Unit resumingConnection();
}

// Java class com.fredhopper.replication.server.ConnectionThread
// CSP model ConnectionThreadRun(n)
interface ConnectionThread extends Worker { }

// Exposes schedule for testing
interface ServerNode extends Node {
	ServerSchedule getSchedule();
}

// CSP model SyncServer(n)
// Java class com.fredhopper.application.SyncServer
// Java class com.fredhopper.replication.server.ReplicationSnapshot
interface SyncServer extends ServerNode,Runnable { 
	SyncServerAcceptor getAcceptor();
	[Far] SyncServerClientCoordinator getCoordinator();
	[Near] ReplicationSnapshot getReplicationSnapshot();
}

interface InternalServer extends SyncServer {
	Unit debug();
}

interface Runnable  {
	Unit run();
}
class FullSystem implements Runnable{
	
	// checkpoints 
	TestData items =
		map[Pair(1,
				map[file("dir1/file1",1),
					file("dir1/file2",2)]),
			Pair(2,
				map[file("dir1/file1",3),
					file("dir1/file2",4)]),
			Pair(3,
				map[file("dir2/file1",3),
					file("dir2/file2",4)]),
			Pair(4,
				map[file("dir3/file1",3),
					file("dir3/file2",4)]),
			Pair(5,
				map[file("dir2/dir21/file1",1),
					file("dir2/dir21/file2",2),
					file("dir2/dir22/file3",3),
					file("dir2/dir22/file4",4)])
 		];
 		
 	// schedules
 	ServerSchedule schedules = 
 		set[FileItem("dir2","dir2/dir21"),FileItem("dir2","dir2/file"),SearchItem("dir3")]; 
	
	// 6 clients
	Set<ClientId> cids = set[0,1,2,3,4,5];
	
	Unit run() {
		Runnable r=new local ReplicationSystem(items,schedules,cids);
		r!run();
	}

}

class SmallSystem implements Runnable{

	TestData items =
		map[Pair(1,
				map[file("dir1/file1",1),
					file("dir1/file2",2)]),
			Pair(2,
				map[file("dir1/file1",3),
					file("dir1/file2",4)])];

	ServerSchedule schedules = 
		set[SearchItem(rroot())];

	Set<ClientId> cids = set[0,1];
	
	Unit run() {
		Runnable r=new local ReplicationSystem(items,schedules,cids);
		r!run();
	}
}





class ReplicationSnapshotImpl(
	ServerDataBase db, 
	ServerSchedule schedules) implements ReplicationSnapshot {

	Int count = 0;
	Int update = 0;
	
	//cps increments after each time 
    //changes to be made to item store
	Bool updated = False;
	CheckPoint cps = 0;
	
	// if snapshot is cleaned
	Bool clean = True;
	
	Set<ServerReplicationItem> items = EmptySet;
	
	Set<ServerReplicationItem> getItems() {
		return this.items;
	}
	
	
	//  Updating replication snapshot
	//  @param makeChange currently specifies whether to actually 'refresh'
	
	Unit refreshSnapshot(Bool makeChange) {
		count = count + 1; //for debug
		if (clean) {
			// advance check point only after data 
			// has been replicated to all clients
			if (makeChange) {
				this.cps = this.cps + 1;
			}
			
			updated = this.db.refresh(makeChange);
			if (updated) {
				update = update + 1; //for debug
				
				this.createReplicationItems();
				Set<ServerReplicationItem> titems = this.getItems();
				while (hasNext(titems)) {
					Pair<Set<ServerReplicationItem>,ServerReplicationItem> ni = next(titems);
					titems = fst(ni);
					ServerReplicationItem item = snd(ni);
					item.refresh();
				}

				clean = False;
			}
		}
		
	}
	
	Unit createReplicationItems() {
		ServerSchedule tsc = schedules;
		while (hasNext(tsc)) {
			Pair<ServerSchedule,Schedule> ns = next(tsc);
			this.replicationItem(snd(ns));
			tsc = fst(ns);
		}
	}
	
	
	Unit replicationItem(Schedule schedule) {
		if (isSearchItem(schedule)) {
			ServerReplicationItem item = new local SearchDirectoryItem(left(item(schedule)),this.db);
			this.items = Insert(item,this.items);
		} 
		
		
		//if (isFileItem(schedule)) { 
		//	// this will be defined in the deltas
		//	Pair<FileId,String> it = right(item(schedule));
		//	ServerReplicationItem item = new local ReplicationFilePattern(fst(it),snd(it),this.db);
		//	this.items = Insert(item,this.items);
		//} 
		
		//if (isLogItem(schedule)) { 
		//	// this will be defined in the deltas
		//	ServerReplicationItem item = new local ReplicationLogItem(left(item(schedule)),this.db);
		//	this.items = Insert(item,this.items);
		//} 
		
	}
	
	//Clear snapshot
	Unit clearSnapshot() {
		this.items = EmptySet;
		clean = True;
	}
	
	Bool hasUpdated() {
		return this.updated;
	}
	
	Int getIndexingId() {
		return this.cps;
	}

}

//ReplicationSystem simulator
class ReplicationSystem (
	Map<CheckPoint,Map<FileId,FileContent>> items, 
	ServerSchedule schedules,
	Set<ClientId> cids) implements Runnable {

	Unit run() {
		// One SyncServer
		SyncServer syncserver = new SyncServerImpl(items,schedules,cids);
		syncserver!run();

		Set<[Far] ClientConnector> syncclients = EmptySet;
		Set<[Far] Tester> testers = EmptySet;
		
		Set<ClientId> iterator = cids;
		while (hasNext(iterator)) {
			Pair<Set<ClientId>,ClientId> nt = next(iterator);
			ClientConnector syncclient = new SyncClientImpl(snd(nt));
			syncclient!run();
			syncclients = insertElement(syncclients,syncclient);
			
			Tester tester = new TesterImpl(syncserver,syncclient);
			tester!run();
			testers = insertElement(testers,tester);
			iterator = fst(nt);
		}
		
		Fut<SyncServerAcceptor> acc = syncserver!getAcceptor(); await acc?;
		SyncServerAcceptor acceptor = acc.get;	
		
		Set<ClientConnector> clientIterator = syncclients;
		while (hasNext(clientIterator)) {
			Pair<Set<ClientConnector>,ClientConnector> nt = next(clientIterator);
			ClientConnector syncclient = snd(nt);
			syncclient!setAcceptor(acceptor);
			clientIterator = fst(nt);
		}
			
	}

} 

// @param qualified is an absolute path from 'root' in db
// @param db points to the database that stores the whole file structure and it responsible for update
class SearchDirectoryItem(FileId qualified, ServerDataBase db) 
implements ServerReplicationItem {

	Directory snapshot = emptyDir(rroot());
	
	{
		//this.cleanup();
		this.snapshot = updateDirWithDir(emptyDir(rroot()),emptyDir(qualified)); 
	}  
	
	FileEntry getContents() {
		return dirContent(snapshot);
	}
	
	Command getCommand() { 
		return AppendSearchFile; 
	}
	
	ReplicationItemType getType() { 
		return SearchReplicationDirectory; 
	}
	
	FileId getAbsoluteDir() {
		return qualified;
	}
	
	 Unit refresh() {
		// get all file names for the newest check points
		Set<FileId> fids = this.db.listCheckPointFiles();
		while (hasNext(fids)) {
			Pair<Set<FileId>,FileId> nt = next(fids);
			fids = fst(nt);
			FileId fid = snd(nt);
			
			// check if this file is in the item's directory
			if (isAncester(this.qualified,fid)) {
				FileContent content = this.db.getContent(fid);
				snapshot = updateDirWithContent(snapshot,fid,content);
			}
		}
	}
	
	 Unit cleanup() {
		this.snapshot = updateDirWithDir(emptyDir(rroot()),emptyDir(qualified)); 
	}
	
}

[COG] class SyncServerImpl(
		Map<CheckPoint,Map<FileId,FileContent>> datas,
		ServerSchedule schedules,
		Set<ClientId> clients) implements InternalServer, SyncServer {
	
	Bool shutDown = False;
	
	Int debug = 0; //for debugging
	
	[Far] SyncServerClientCoordinator coordinator = null;
	[Near] SyncServerAcceptor acceptor = null;
	[Near] ServerDataBase db = null;
	[Near] ReplicationSnapshot snapshot = null;
	
	{
		this.db = new local DataBaseImpl(datas);
		this.snapshot = new local ReplicationSnapshotImpl(this.db,this.schedules);
	}
	
	Unit run() {
		
		this.coordinator = new SyncServerClientCoordinatorImpl(this,snapshot,clients);
		this.acceptor = new local SyncServerAcceptorImpl(this);
		this.coordinator!process();
	}
	
	DataBase getDataBase() {
		DataBase db2 = this.db;
		return db2;
	}
	
	ServerSchedule getSchedule() {
	 	ServerSchedule ss = schedules;
		return ss;
	}
	
	ReplicationSnapshot getReplicationSnapshot() {
		ReplicationSnapshot rs = this.snapshot;
		return rs;
	}
	
	
	 // For debugging/yielding
	 
	Unit debug() { debug = debug + 1; }
	
	Bool isShutdownRequested() {
		return shutDown;
	}
	
	Unit requestShutDown() {
		this.shutDown = True;
	}

	SyncServerClientCoordinator getCoordinator() {
		await coordinator != null;
		return this.coordinator;
	}
	
	SyncServerAcceptor getAcceptor() {
		await acceptor != null;
		return this.acceptor;
	}
	

}


  //Checks that the file store in the data base of the actual node
  //is the same as the file store in the data base of the expected node.  
 
class TesterImpl(ServerNode expected, Node actual) implements Tester {
	
	ServerSchedule schedule = EmptySet; 
	Set<Triple<FileId,FileContent,FileContent>> result = EmptySet;
	
	Unit run() {
		Bool shutdown = False;
		while (~ shutdown) {
			Node n = this.actual;
			Fut<Bool> sd = n!isShutdownRequested(); await sd?; 
			shutdown = sd.get;
		}
		this.assertData();
	}
	
	Unit assertData() {
		ServerNode ex = this.expected;
		Fut<DataBase> fe = ex!getDataBase();
		DataBase e = fe.get;
	
		Fut<ServerSchedule> schf = ex!getSchedule();
		this.schedule = schf.get;
		
		Node act2 = this.actual;
		Fut<DataBase> fa = act2!getDataBase();
		DataBase a = fa.get;
		
		this.checkDatas(e,a);
	}
	
	Unit checkDatas(DataBase e, DataBase a) {
		//check against schedule!
		ServerSchedule ss = this.schedule;
		while (hasNext(ss)) {
			Pair<ServerSchedule,Schedule> ns = next(ss);
			this.checkData(snd(ns),e,a);
			ss = fst(ns); 
		}
	}
	
	
	Unit checkData(Schedule s, DataBase e, DataBase a) {
		if (isLeft(item(s))) {
			FileId id = left(item(s));
			Fut<FileContent> ccg = e!getContent(id); 
			FileContent ce = ccg.get; 
			
			Fut<FileContent> ccf = a!getContent(id); 
			FileContent ca = ccf.get; 
				
			if (isFile(ce)) {
				this.compareFile(file(id,content(ce)),file(id,content(ca)));
			} else {
				this.compareDir(dir(id,entries(ce)),dir(id,entries(ca)));
			}
		} 
			
		//handling file pattern (variability)
		
		//if (isRight(item(s))) {
		//	FileId id = fst(right(item(s)));
		//	String pattern = snd(right(item(s)));
			
		//	Fut<FileContent> ccg = e!getContent(id); 
		//	FileContent ce = ccg.get;
			
		//	Fut<FileContent> ccf = a!getContent(id); 
		//	FileContent ca = ccf.get; 
			
		//	if (isFile(ce)) {
		//		if (filter(pattern,id)) {
		//			this.compareFile(file(id,content(ce)),file(id,content(ca)));				
		//		}
		//	} else {
		//		this.compareDir1(pattern,dir(id,entries(ce)),dir(id,entries(ca)));
		//	}			
		//}
	}
	
	//[Adds]
	//Unit compareDir1(String pattern, Directory e, Directory a) {
	//	Set<FileId> fids = filters(pattern,getFileIdFromDir(e));
	//	Set<FileId> eids = filters(pattern,getFileIdFromDir(a));
	//	this.compareFiles(e,a,fids,eids);
	//}
	
	Unit compareDir(Directory e, Directory a) {
		Set<FileId> fids = getFileIdFromDir(e);
		Set<FileId> eids = getFileIdFromDir(a);
		this.compareFiles(e,a,fids,eids);
	}
	
	Unit compareFiles(
		Directory e, Directory a, 
		Set<FileId> fids, Set<FileId> eids) {

		//assert size(fids) == size(eids);
		while (hasNext(fids)) {
			Pair<Set<FileId>,FileId> nd = next(fids);
			FileId id = snd(nd);
			FileContent es = fromJust(getFromEntryIn(e,id));
			FileContent as = fromJust(getFromEntryIn(a,id));
			result = Insert(Triple(id,es,as),result);			
			//assert(es == as);
			fids = fst(nd); 
		}
	}
	
	Unit compareFile(File e, File a) {
		FileId id = getFileId(Left(e));
		FileContent es = getFileContent(Left(e));
		FileContent as = getFileContent(Left(a));
		result = Insert(Triple(id,es,as),result);			
		//assert(es == as);
	}
	
}

{
	Runnable r=new local FullSystem();
	r!run();
	
   //Uncomment the following to test public version
   TestData items =
		map[Pair(1,map[file("dir1/file1",1),file("dir1/file2",2)]),
		    Pair(2,map[file("dir1/file1",3),file("dir1/file2",4)]),
		    Pair(3,map[file("dir2/file1",3),file("dir2/file2",4)]),
		    Pair(4,map[file("dir3/file1",3),file("dir3/file2",4)]),
		    Pair(5,map[file("dir2/dir21/file1",1),file("dir2/dir21/file2",2),file("dir2/dir22/file3",3),file("dir2/dir22/file4",4)])];

	ServerSchedule schedules = 
		set[FileItem("dir2","dir2/dir21"),FileItem("dir2","dir2/file"),SearchItem("dir3")]; 
	
	Set<ClientId> cids = set[0,1,2,3,4,5];
	
	SyncServer syncserver = new SyncServerImpl(items,schedules,cids);
	syncserver!run();

	Set<[Far] ClientConnector> syncclients = EmptySet;
	Set<[Far] Tester> testers = EmptySet;
	
	Set<ClientId> iterator = cids;
	while (hasNext(iterator)) {
		Pair<Set<ClientId>,ClientId> nt = next(iterator);
		ClientConnector syncclient = new SyncClientImpl(snd(nt));
		syncclient!run();
		syncclients = insertElement(syncclients,syncclient);
		
		Tester tester = new TesterImpl(syncserver,syncclient);
		tester!run();
		testers = insertElement(testers,tester);
		iterator = fst(nt);
	}
		
	Fut<SyncServerAcceptor> acc = syncserver!getAcceptor(); await acc?;
	SyncServerAcceptor acceptor = acc.get;	
	
	Set<ClientConnector> clientIterator = syncclients;
	while (hasNext(clientIterator)) {
		Pair<Set<ClientConnector>,ClientConnector> nt = next(clientIterator);
		ClientConnector syncclient = snd(nt);
		syncclient!setAcceptor(acceptor);
		clientIterator = fst(nt);
	}

}


