***
*** An ABS interpreter on the Maude platform
***
*** Copyright (c) 2010 Rudolf Schlatte
*** 
*** Based upon `creol-interpreter.maude' by Marcel Kyas, Olaf Owe, Einar Broch
*** Johnsen, which was generated from interpreter.m4, Copyright (c) 2007, 2008
*** Marcel Kyas
***
***
*** This program is free software; you can redistribute it and/or
*** modify it under the terms of the GNU General Public License as
*** published by the Free Software Foundation; either version 3 of the
*** License, or (at your option) any later version.
***
*** This program is distributed in the hope that it will be useful, but
*** WITHOUT ANY WARRANTY; without even the implied warranty of
*** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*** General Public License for more details.
***
*** You should have received a copy of the GNU General Public License
*** along with this program.  If not, see <http://www.gnu.org/licenses/>.
***



*** The basic concepts of Abs's data type.
***
fmod ABS-DATA-SIG is

  sorts Expr Data .
  subsort Data < Expr .

  op null : -> Data [ctor format (! o)] .

  sorts   NeExprList ExprList NeDataList DataList .
  subsort Expr < NeExprList < ExprList .
  subsort Data < NeDataList < DataList .
  subsort DataList < ExprList .
  subsort NeDataList < NeExprList .

  op emp : -> DataList [ctor] .

  op _::_ : ExprList ExprList -> ExprList
    [ctor assoc id: emp prec 27 format (d r os d)] .
  op _::_ : NeExprList ExprList -> NeExprList [ctor ditto] .
  op _::_ : ExprList NeExprList -> NeExprList [ctor ditto] .
  op _::_ : DataList DataList  -> DataList [ctor ditto] .
  op _::_ : NeDataList DataList  -> NeDataList [ctor ditto] .
  op _::_ : DataList NeDataList  -> NeDataList [ctor ditto] .

endfm

view Data from TRIV to ABS-DATA-SIG is
  sort Elt to Data .
endv

view Expr from TRIV to ABS-DATA-SIG is
  sort Elt to Expr .
endv


fmod ABS-DATA-VID is
  extending ABS-DATA-SIG .
  protecting STRING .
  protecting QID .

  sort Vid .
  subsort Qid < Vid < Expr .

  *** Variable references are named by Qids directly.

  *** Instance variable references are decorated:

  op @_ : Qid -> Vid [ctor] .
endfm

view Vid from TRIV to ABS-DATA-VID is
  sort Elt to Vid .
endv

fmod ABS-DATA-VIDLIST is
  protecting LIST{Vid} * (sort List{Vid} to VidList,
                          sort NeList{Vid} to NeVidList,
                          op nil : -> List{Vid} to noVid,
                          op __ : List{Vid} List{Vid} -> List{Vid} to _`,_ [format (d r os d)]) .
endfm



*** Specification of all Abs expressions.  This is the abstract syntax.
*** Semantics will be provided by the different modules.
***
fmod ABS-EXPRESSION is

  protecting ABS-DATA-VIDLIST .
  protecting ABS-DATA-SIG .
  protecting STRING .

  sorts CaseBranch CaseBranchList .
  subsort CaseBranch < CaseBranchList .
  *** KLUDGE (rs 2010-04-20) Only certain kinds of expressions can be used as
  *** pattern: literals and variable references.  We should introduce a sort
  *** `Pattern' and use it.  For now, we rely on the compiler to only produce
  *** valid pattern expressions.
  op _=>_ : Expr Expr -> CaseBranch [ctor prec 39] .
  op _;_ : CaseBranchList CaseBranchList -> CaseBranchList
    [ctor assoc id: noBranch format (d b os d)] .
  op noBranch : -> CaseBranch .

  *** function application
  op _(_) : String ExprList -> Expr [ctor prec 12 format (! o d d d)] .
  *** Helpers for function application, generated for each function.
  op fparams : String -> VidList .
  op fdefn : String -> Expr .
  *** Translation from Abs to Maude expressions for basic datatypes (Int,
  *** Bool, String etc).
  op $builtin : String -> Expr [ctor format (r o)] .
  *** constructor terms
  op _[_] : String ExprList -> Expr [ctor prec 12 format (! o d d d)] .
  op _[_] : String DataList -> Data [ctor prec 12 format (! o d d d)] .
  *** conditional
  op if_th_el_fi : Expr Expr Expr -> Expr [ctor] .
  *** case expression
  op case_of {_} : Expr CaseBranchList -> Expr [ctor] .
  *** let expression
  op let_=_in_ : VidList ExprList Expr -> Expr [ctor] .
  *** guard expression
  op ?(_)  : Expr -> Expr [ctor format (! o d d d)] .
  *** Error terms
  op $error : String -> Expr [ctor format (r o)] .

endfm

*** Specification of the Bool datatype.
***
fmod ABS-DATA-BOOL is

  protecting ABS-EXPRESSION .

  vars B B' : Bool .
  vars D D' : Data .
  vars E : Expr .

  
  op _asBool : Data -> Bool .
  eq "True"[ emp ] asBool = true .
  eq "False"[ emp] asBool = false .
  op _asAbsBool : Bool -> Data .
  eq true asAbsBool = "True"[ emp ] .
  eq false asAbsBool = "False"[ emp ] .

  eq fparams("==") = 'D1, 'D2 .
  eq fdefn("==") = $builtin("==") .
  eq fparams("/=") = 'D1, 'D2 .
  eq fdefn("/=") = $builtin("/=") .

  eq fparams("~") = 'D .
  eq fdefn("~") = $builtin("~") .
  eq fparams("&&") = 'D1, 'D2 .
  eq fdefn("&&") = $builtin("&&") .
  eq fparams("||") = 'D1, 'D2 .
  eq fdefn("||") = $builtin("||") .
  
endfm



*** Specification of floats and functions on floats.
***
fmod ABS-DATA-FLOAT is
  extending ABS-DATA-BOOL .
  protecting FLOAT .

  op _[_] : String Float -> Data [ctor prec 12 format (! o d d d)] .

  vars F F' : Float .

  op _asFloat : Data -> Float .
  eq "float"[F] asFloat = F .

  eq "-" ("float"[F]) = "float"[-(F)] .
  eq "+" ("float"[F] :: "float"[F']) = "float"[F + F'] .
  eq "-" ("float"[F] :: "float"[F']) = "float"[ _-_(F, F')] .
  eq "*" ("float"[F] :: "float"[F']) = "float"[F * F'] .
  eq "/" ("float"[F] :: "float"[F']) = "float"[F / F'] .
  eq "%" ("float"[F] :: "float"[F']) = "float"[F rem F'] .
  eq "**" ("float"[F] :: "float"[F']) = "float"[F ^ F'] .

  eq "<"  ("float"[F] :: "float"[F']) = (F < F') asAbsBool .
  eq "<=" ("float"[F] :: "float"[F']) = (F <= F') asAbsBool .
  eq ">"  ("float"[F] :: "float"[F']) = (F > F') asAbsBool .
  eq ">=" ("float"[F] :: "float"[F']) = (F >= F') asAbsBool .

endfm



*** Specification of integers and functions on integers.
***
fmod ABS-DATA-INT is
  extending ABS-DATA-FLOAT .

  protecting INT .
  protecting RANDOM .
  protecting CONVERSION .

  op _[_] : String Int -> Data [ctor prec 12 format (! o d d d)] .

  vars I I' : Int .
  var N : Nat .

  op _asInt : Data -> Int .
  eq "int"[I] asInt = I .

  op _asNat : Data -> Nat .
  eq "int"[N] asNat = N .

  eq fparams("--") = 'I .
  eq fdefn("--") = $builtin("--") .
  eq fparams("+") = 'I1, 'I2 .
  eq fdefn("+") = $builtin("+") .
  eq fparams("-") = 'I1, 'I2 .
  eq fdefn("-") = $builtin("-") .
  eq fparams("*") = 'I1, 'I2 .
  eq fdefn("*") = $builtin("*") .
  eq fparams("/") = 'I1, 'I2 .
  eq fdefn("/") = $builtin("/") .
  eq fparams("%") = 'I1, 'I2 .
  eq fdefn("%") = $builtin("%") .
  
  *** eq "**" ("int"[I] :: "int"[I']) = "int"[I ^ I'] .
  *** eq "random" ("int"[I]) = "int"[random(I)] .
  *** eq "real_of_int" ("int"[I]) = "float"[float(I)] .

  eq fparams("<") = 'I1, 'I2 .
  eq fdefn("<") = $builtin("<") .
  eq fparams("<=") = 'I1, 'I2 .
  eq fdefn("<=") = $builtin("<=") .
  eq fparams(">") = 'I1, 'I2 .
  eq fdefn(">") = $builtin(">") .
  eq fparams(">=") = 'I1, 'I2 .
  eq fdefn(">=") = $builtin(">=") .

endfm



*** Specification of strings and functions on strings.
***
fmod ABS-DATA-STRING is
  extending ABS-DATA-INT .

  protecting STRING .

  op _[_] : String String -> Data [ctor prec 12 format (! o d d d)] .

  vars S S' : String .
  vars M N : Nat .

  op _asString : Data -> String .
  eq "str"[S] asString = S .

  eq "+" ("str"[S] :: "str"[S']) = "str"[S + S'] .
  eq "#" ("str"[S]) = "int"[length(S)] .
  eq "ascii" ("str"[S]) = "int"[ascii(S)] .
  eq "char" ("int"[N]) = "str"[char(N)] .
  eq fparams("substr") = 'S, 'L, 'R .
  eq fdefn("substr") = $builtin("substr") .
  eq fparams("strlen") = 'S .
  eq fdefn("strlen") = $builtin("strlen") .
  eq "find" ("str"[S] :: "str"[S'] :: "int"[N]) = "int"[find(S, S', N)] .
  eq "rfind" ("str"[S] :: "str"[S'] :: "int"[N]) = "int"[rfind(S, S', N)] .

  eq "<" ("str"[S]:: "str"[S']) = (S < S') asAbsBool .
  eq "<=" ("str"[S]:: "str"[S']) = (S <= S') asAbsBool .
  eq ">" ("str"[S]:: "str"[S']) = (S > S') asAbsBool .
  eq ">=" ("str"[S]:: "str"[S']) = (S >= S') asAbsBool .


  --- Conversions.  Since Abs does not support rational numbers yet,
  --- we may have failures here which will remain unchecked.
  protecting CONVERSION .
  var I : Int .
  var F : Float .

  eq "string_of_int" ("int"[I]) = "str"[string(I, 10)] .
  eq "int_of_string" ("str"[S]) = "int"[rat(S, 10)] .
  eq "string_of_real" ("float"[F]) = "str"[string(F)] .
  eq "real_of_string" ("str"[S]) = "float"[float(S)] .

endfm


*** Specification of times and functions on times.
***
fmod ABS-DATA-TIME is
  extending ABS-DATA-SIG .
  extending ABS-DATA-INT .

  *** The central problem is to evaluate this function, since the clock is
  *** floating around in the global state.
  eq fparams("currentms") = noVid .
  eq fdefn("currentms") = $builtin("currentms") .
endfm



***************************************************************************
***
*** Signature of programs and states.
***
***************************************************************************

*** The sort of a class identifier.
***
mod ABS-CID is
  protecting CONFIGURATION .
  protecting STRING .
  subsort String < Cid .

  op Class : -> Cid [ctor] .
  op None : -> Cid [ctor] .
endm

view Cid from TRIV to ABS-CID is
  sort Elt to Cid .
endv


*** The sort of an object identifier.
***
mod ABS-OID is
  protecting ABS-CID .
  protecting NAT .
  protecting CONVERSION .
  extending ABS-DATA-SIG .

  subsort Oid < Data .

  --- Constructor of object names
  op ob(_) : String -> Oid [ctor format (d d ! o d)] .

  var B : String .
  var F : Nat .

  --- Create a new fresh name for an object
  op newId : String Nat -> String .
  eq newId(B, F)  = B + "-" + string(F,10) .

endm

view Oid from TRIV to ABS-OID is
  sort Elt to Oid .
endv

*** The sort of a delta identifier.
***
mod ABS-DID is
  protecting STRING .
  sort Did .
  subsort String < Did .
endm

view Did from TRIV to ABS-DID is
  sort Elt to Did .
endv


mod ABS-DATA-LABEL is

  extending ABS-DATA-SIG .
  protecting ABS-OID .

  sort Label .
  subsort Label < Data .

  --- A label consists of the id of the sending object plus a unique number.
  --- This is used in the $cont statement to find the object which should
  --- continue execution after a synchronously-called process terminates.
  op label : Oid Nat -> Label [ctor format (o o)] .
endm

view Label from TRIV to ABS-DATA-LABEL is
  sort Elt to Label .
endv


*** The DATATYPES module collects all predefined data types into one module.
mod ABS-DATATYPES is
    extending ABS-DATA-SIG .
    extending ABS-EXPRESSION .
    extending ABS-DATA-BOOL .
    extending ABS-DATA-LABEL .
    extending ABS-DATA-FLOAT .
    extending ABS-DATA-INT .
    extending ABS-DATA-STRING .
    extending ABS-DATA-TIME .
    extending ABS-OID .
endm


***
*** Binding variables to values.
***
*** Uses MAP from prelude.
***
mod ABS-SUBST is
  protecting ABS-DATATYPES .
  extending MAP{Vid, Data} * (sort Map{Vid,Data} to SSubst,
                              sort Entry{Vid,Data} to Binding,
                              op empty : -> Map{Vid,Data} to noSubst,
                              op insert : Vid Data Map{Vid,Data} -> Map{Vid,Data} to $insert ) .

  sort Subst .
  subsort SSubst < Subst .
  vars A A' : Vid .
  var AL : VidList .
  vars D D' : Data .
  var DL : DataList .
  var S1 : Subst . 
  var S2 : SSubst .

  *** Lazy composition operator for substitutions
  *** FIXME: make this operator have less precedence than |->

  op _::_ : Subst Subst -> Subst [assoc] .
  eq (S1 :: S2)[A] = if $hasMapping(S2, A) then S2[A] else S1[A] fi .

  op hasMapping : Subst Vid -> Bool .
  eq hasMapping(S2, A) = $hasMapping(S2, A) .
  eq hasMapping(S1 :: S2, A) = $hasMapping(S2, A) or hasMapping(S1, A) .

  op insert : Vid Data Subst -> Subst .
  eq insert(A, D, S2) = $insert(A, D, S2) .
  eq insert(A, D, S1 :: S2) = S1 :: $insert(A, D, S2) .

  *** Replace an existing binding even in the middle of the SSubst stack.
  op update : Vid Data Subst -> Subst .
  eq update(A, D, S1 :: S2) = if $hasMapping(S2, A) then S1 :: $insert(A, D, S2)
      else update(A, D, S1) :: S2 fi .
  ceq update(A, D, S2) = $insert(A, D, S2)
  if $hasMapping(S2, A) .       *** Block if no mapping exists.

  --- Create a substitution from a list of identifiers and data values.
  op createSubst : VidList DataList -> SSubst .
  eq createSubst(AL, DL) = $createSubst(noSubst, AL, DL) .
  op $createSubst : SSubst VidList DataList -> SSubst .
  eq $createSubst(S2, noVid, emp) = S2 .
  eq $createSubst(S2, (A, AL), (D :: DL)) = 
    $createSubst($insert(A, D, S2), AL, DL) .
endm



*** Abs Statements
***
*** The following module defines all elementary statements of Abs.
***
*** Colouring rules: Statements from the programmer syntax are displayed
*** in blue.  Statements inserted by the compiler only are displayed in
*** cyan.  Statements inserted by the run-time system are displayed in
*** red.  It may indicate a problem if a red term appears in a
*** configuration.

mod ABS-STATEMENT is

  protecting ABS-DATA-VIDLIST .
  protecting ABS-EXPRESSION .
  protecting ABS-SUBST .
  protecting ABS-CID .

  sort Stmt .

  op skip : -> Stmt [ctor format (b o)] .
  op suspend : -> Stmt [ctor format (b o)] .
  op await_ : Expr -> Stmt [ctor format (b o d)] .
  op assert_ : Expr -> Stmt [ctor format (b o d)] .
  op assign(_;_) : Vid Expr -> Stmt [ctor format (b d o b o b o)] .
  op new(_;_;_) : Vid String ExprList -> Stmt [ctor format (b d o b o b o b o)] .
  op newcog(_;_;_) : Vid String ExprList -> Stmt [ctor format (b d o b o b o b o)] .
  op asynccall(_;_;_;_) : Vid Expr String ExprList -> Stmt [ctor format (b d o b o b o b o b o)] .
  op synccall(_;_;_;_) : Vid Expr String ExprList -> Stmt [ctor format (b d o b o b o b o b o)] .
  op original(_;_) : Vid ExprList -> Stmt [ctor format (b d o b o b o)] .
  op $call(_;_;_;_;_) : Label Oid String DataList Bool -> Stmt [ctor format (r d o r o r o r o r o r o)] .
  op get(_;_)  : Vid Vid -> Stmt [ctor format (b d o b o b o)] .
  op get(_;_)  : Label Vid -> Stmt [ctor ditto] .

  op return(_) : Expr -> Stmt [ctor format (c d o b o)] .
  op $mark(_) : Expr -> Stmt [ctor format (r d o r o)] .
  op $free(_) : Expr -> Stmt [ctor format (r d o r o)] .

  op $cont_ : Label -> Stmt [ctor format (r o d)] .

  op $beginscope : -> Stmt [ctor format (r o)] .
  op $vardecl(_;_) : Vid Expr -> Stmt [ctor format (r d o r o r o) ] .
  op $endscope : -> Stmt [ctor format(r o)] .

  --- Assertion Failure.
  --- This `statement' represents an assertion failure.  It 
  --- stops evaluation of the executing object at that point.
  op failure_ : Expr -> [Stmt] [ctor format (r! o d)] .

endm

view Stmt from TRIV to ABS-STATEMENT is
  sort Elt to Stmt .
endv



*** Specification of compound statements.
***
mod ABS-STM-LIST is
  protecting ABS-STATEMENT .                
  protecting LIST{Stmt} * (sort List{Stmt} to StmtList,
                           sort NeList{Stmt} to NeStmtList,
                           op nil : -> List{Stmt} to noStmt,
                           op __ : List{Stmt} List{Stmt} -> List{Stmt} to _;_ [format (d r o d)]) .

  op if_th_el_fi : Expr StmtList StmtList -> Stmt [ctor format (b o b o b o b o)] . 
  op while_do_od : Expr StmtList -> Stmt [ctor format (b o b o b o)] .

  var SL : StmtList .
  var E : Expr .

endm


mod ABS-PROCESS is

  protecting ABS-STM-LIST .

  sort Process .

  op idle : -> Process [ctor format (!b o)] .  
  op notFound : -> Process [ctor format (!b o)] .  
  op {_|_} : Subst StmtList -> Process [ctor format (r o rni o r o)] . 

endm

view Process from TRIV to ABS-PROCESS is
  sort Elt to Process .
endv


*** Specifies a process pool, here a multiset of Processes
***
mod ABS-PROCESS-POOL is
  protecting ABS-PROCESS .

  sort MProc .
  subsort Process < MProc .
  op noProc : -> MProc [ctor] .
  op _,_ : MProc MProc -> MProc
    [ctor assoc comm id: noProc prec 41 format (d r os d)] .

endm


*** A method declaration
***
mod ABS-METHOD is
  protecting ABS-STM-LIST .

  sort Method .
  op <_: Method | Param:_, Code:_> : 
    String VidList StmtList -> Method
    [ctor format (nib ! ob o d sb o d sb o b o)] .

endm

view Method from TRIV to ABS-METHOD is
  sort Elt to Method .
endv

*** The sort of a Class Modifier
***
mod ABS-CLASSMODIFIER is
  protecting ABS-CID .
  protecting ABS-METHOD .
  protecting STRING .

  sort ClassModifier .

  --- Constructors
  op addM : Cid Method -> ClassModifier 
  [ctor format (n o)] .
  op removeM : Cid String -> ClassModifier
  [ctor format (n o)] .
endm

view ClassModifier from TRIV to ABS-CLASSMODIFIER is
  sort Elt to ClassModifier .
endv



*** Abs's state configuration.
***
*** Modeled after the CONFIGURATION module in "prelude.maude"
***
mod ABS-CONFIGURATION is
  protecting ABS-DATA-LABEL .
  protecting ABS-PROCESS-POOL .
  protecting ABS-OID .
  protecting ABS-DID .
  protecting SET{Method} * (sort Set{Method} to MMtd,
                            op empty : -> Set{Method} to noMethod) .
  protecting SET{String} * (sort Set{String} to StringSet) .
  protecting SET{ClassModifier} * (sort Set{ClassModifier} to ClassModifierSet,
                                   op empty : -> Set{ClassModifier} to noModifier) .
  protecting LIST{Did} * (sort List{Did} to DeltaList,
                         op nil : -> List{Did} to noDelta) .
 
  --- Define object identifiers.
  protecting CONVERSION .

  sorts Future Class Clock Delta Cog .
  subsorts Class Future Clock Delta Cog < Configuration .
  vars B M : String .
  var C : Cid .
  vars O O' : Oid .
  vars L S S1 : Subst .
  vars P P' : Process .
  vars MS MS1 : MMtd .
  var W : MProc .
  var AL : VidList .
  vars SL SL1 : StmtList .
  var EL : ExprList .
  var D : Data .
  var DL : DataList .
  var N : Label .
  vars F F' : Nat .
  var CN : Configuration .

  --- Invocation protocol.
  ---
  --- Invocation message generated by the calling object:
  ---    invoc(R,N,M,DL,S)
  --- R: The receiver.
  --- N: The label.
  --- M: The called method.
  --- DL: The actual arguments.
  --- S: Flag indicating whether the call was made synchronously, i.e. whether
  ---    a $cont statement should be generated at the end.
  op invoc(_,_,_,_,_) : Oid Label String DataList Bool -> Msg
    [ctor format (b d o  b so  b so  b so  b so b on)] .
  --- Invocation message received by the called object, pre method lookup:
  op findMethod(_,_,_,_,_,_,_) : String Cid DeltaList Label Oid DataList Bool -> Msg .

  --- Invocation message plus method object and defining Delta, received by
  --- the called object:
  op foundMethod(_,_,_,_,_,_) : Method Did Label Oid DataList Bool -> Msg .
  --- Process creation in target object:
  op makeProcess(_,_,_,_,_) : Method Did Label DataList Bool -> Process .


  --- Error and warning messages are intended to stop the machine.
  --- For now, nothing is emitting these.
  --- op error(_) : String -> [Msg] [ctor format (nnr r o! or onn)] .
  op warning(_) : String -> [Msg] [ctor format (nnr! r! r! or onn)] .

  --- Terms of sort Object represent objects in the run-time configuration.
  ---
  op <_:_ | Cog:_, Att:_, Pr:_, PrQ:_, Lcnt:_> : 
    Oid Cid String Subst Process MProc Nat -> Object 
    [ctor format (nr d d g ++r nir o  r ni o  r ni o  r ni o  r ni o--  r on)] .

  --- Terms that represent futures.
  ---
  op <_: Future | Name:_, Completed:_, References:_, Value:_> :
    Label String Bool Nat Data -> Future
    [ctor format (nr d d g ++r ir o  r i o  r i o  r i o--  r on)] .

  --- Define Classes.
  --- Class declaration.
  ---
  op <_: Class | Deltas:_, Param:_, Att:_, Mtds:_, Ocnt:_> : 
    Cid DeltaList VidList Subst MMtd Nat -> Class 
    [ctor format (ng ! og o d  sg m d  sg o d  sg o d  sg++ o o  gni o-- g on)] .

  op <_: Clock | Limit:_> : Nat Nat -> Clock
    [ctor format(nb m! ob b b b m! b n)] .

  *** Define Deltas
  op <_: Delta | _ > : Did ClassModifierSet -> Delta
    [ctor format (nm ! om o d  sm++ o on)] .

  *** Cogs.  The second argument is of type Data since it can be an Oid (the
  *** currently active object) or null.  The first argument is a unique
  *** identifier - we use the string content of the Oid of the first object
  *** contained inside the cog (to evade the need for a global counter term).
  op <_: Cog | Object:_ > : String Data -> Cog
    [ctor format (cn o! o c d d o! c on ) ] .

  *** Useful for real-time maude, and in general for accessing the whole
  *** configuration.  FIXME: We should use another name, since State is used
  *** in LOOP-MODE.
  sort State .

  op {_} : Configuration -> State [ctor] .

endm


*** Definition of the family of evaluation functions.
***
mod ABS-EVAL is
  protecting ABS-CONFIGURATION .
  protecting ABS-DATA-VID .

  vars L L' : Label .
  vars E E' E'' : Expr .
  vars D D' : Data .
  var DL : DataList .
  var EL : ExprList .
  var NeEL : NeExprList .
  var CBL : CaseBranchList .
  vars A A' : Vid .
  var AL : VidList .
  vars Q C : String .
  var QID : Qid .
  vars S S' : Subst .
  var R : MatchResult .
  var SS : SSubst .
  vars ST ST' : Stmt . 
  vars SL SL1 SL2 : StmtList .
  var CN : Configuration .
  var CL : Class .
  var OB : Object .
  var MS : Msg .
  var N : Nat .
  var B : Bool .

  --- Check if a message is in the queue.
  op completed : Label Configuration -> Bool .
  eq completed(L, < L : Future | Name: Q, Completed: B, References: N, Value: D > CN) = B .
  eq completed(L, CN) = false [owise] .

  *** evaluate `Expr' with variable bindings `Subst', configuration
  *** `Configuration' and time `Nat' (constant 0 in the untimed case).
  op eval : Expr Subst Configuration Nat -> Data .
  op evalList : ExprList Subst Configuration Nat -> DataList [strat (1 0 0 0)] .
  op enabled : StmtList Subst Configuration Nat -> Bool .
  op ready : StmtList Subst Configuration Nat -> Bool .

  eq eval(D, S, CN, N) = D .

  *** Normal variable lookup.  Can be either instance or local variable.
  eq eval(QID, S, CN, N) =  S [QID] .
  *** Instance variable lookup.  The distinction between @ and raw qids needs
  *** to be made in all lookup operations.
  eq eval(@ QID, (SS :: S), CN, N) =  SS [QID] .
  *** Function expansions are expressions, subject to further evaluation.
  *** They are not evaluated in the current environment but in the environment
  *** in which they are defined (which is currently always empty).
  eq eval(Q(EL), S, CN, N) = eval(fdefn(Q), 
      createSubst(fparams(Q), evalList(EL, S, CN, N)), CN, N) .
  eq eval(Q [EL], S, CN, N) = Q [ evalList(EL, S, CN, N) ] .
  eq eval(?(QID), S, CN, N) = completed(S[QID], CN) asAbsBool .
  eq eval(?(@ QID), (SS :: S), CN, N) = completed(SS[QID], CN) asAbsBool .
  eq eval(?(L), S, CN, N) = completed(L, CN) asAbsBool .
  eq eval(if E th E' el E'' fi, S, CN, N) =
    if eval(E, S, CN, N) asBool
    then eval(E', S, CN, N)
    else eval(E'', S, CN, N) fi .
  eq eval(let AL = EL in E, S, CN, N) = 
    eval(E, S :: createSubst(AL, evalList(EL, S, CN, N)), CN, N) .

  *** evaluate a case statement.  If the pattern matches, augment environment
  *** with the resulting bindings.
  sort MatchResult .
  subsort Subst < MatchResult .
  op noMatch : -> MatchResult [ctor] .
  op match : Data Expr Subst -> MatchResult .
  eq match(D, E, S) = $match(D, E, S, noSubst) .
  op $match : Data Expr Subst MatchResult -> MatchResult .
  eq $match(D, E, S, noMatch) = noMatch .
  eq $match(D, D, S, R) = R .           *** matching two literals
  eq $match(D, '_, S, R) = R .       *** "Don't care" placeholder
  eq $match(D, A, S, R) =               *** Create / check variable binding
    if hasMapping(S, A)
    then
      $match(D, S[A], S, R)
    else
      if hasMapping(R, A)
      then $match(D, R[A], S, R)       *** Match against existing binding
      else insert(A, D, R)             *** Generate new binding
      fi
    fi .
  eq $match(Q[D :: DL], Q[E :: EL], S, R) = *** Destructure constructor pattern
    $match(Q[DL], Q[EL], S, $match(D, E, S, R)) .
  eq $match(D, E, S, R) = noMatch [owise] .

  *** internal operator $case avoids endless loop between "case D of" and
  *** "case E of" when first case branch doesn't match
  op $case : Data CaseBranchList -> Expr .
  ceq eval($case(D, (E => E') ; CBL), S, CN, N) = 
    if R == noMatch
    then eval($case(D, CBL), S, CN, N)
    else eval(E', S :: R, CN, N) fi
  if R := match(D, E, S) .
  *** eq eval($case(D, noBranch), S, CN) = $error("No match in case expression") .

  eq eval(case E of { CBL }, S, CN, N) = 
    eval($case(eval(E, S, CN, N), CBL), S, CN, N) .

  --- Evaluate lists of expressions.
  eq evalList(emp, S, CN, N) = emp .
  eq evalList(noVid, S, CN, N) = emp .
  eq evalList(DL, S, CN, N) = DL .
  eq evalList(E, S, CN, N) = eval(E, S, CN, N) .
  eq evalList(E :: NeEL, S, CN, N) =
    eval(E, S, CN, N) :: evalList(NeEL, S, CN, N) .

  --- Enabledness
  eq enabled(await E ; SL, S, CN, N) = eval(E, S, CN, N) asBool .
  eq enabled(SL, S, CN, N) = true [owise] .

  --- The ready predicate holds, if a statement is ready for execution,
  --- i.e., the corresponding process may be waken up.
  eq ready(get(QID ; A') ; SL , S, CN, N) = completed(S[QID], CN) . 
  eq ready(get(@ QID ; A') ; SL , (SS :: S), CN, N) = completed(SS[QID], CN) . 
  eq ready(get(L ; A') ; SL , S, CN, N) = completed(L, CN) . 
  eq ready(SL, S, CN, N) = enabled(SL, S, CN, N) [owise] .

  *** Evaluate various builtin functions.

  *** ABS-DATA-BOOL
  eq eval($builtin("=="), S, CN, N) = (S['D1] == S['D2]) asAbsBool .
  eq eval($builtin("/="), S, CN, N) = (S['D1] =/= S['D2]) asAbsBool .
  eq eval($builtin("~"), S, CN, N) = (not ((S['D]) asBool)) asAbsBool .
  eq eval($builtin("&&"), S, CN, N) = ((S['D1]) asBool and (S['D2]) asBool) asAbsBool .
  eq eval($builtin("||"), S, CN, N) = ((S['D1]) asBool or (S['D2]) asBool) asAbsBool .
  
  *** ABS-DATA-INT
  eq eval($builtin("--"), S, CN, N) = "int"[-(S['I]) asInt] .
  ceq eval($builtin("+"), S, CN, N) = "int"[I1:Int + I2:Int]
  if "int"[I1:Int] := S['I1] /\ "int"[I2:Int] := S['I2] .
  eq eval($builtin("-"), S, CN, N) = "int"[(S['I1]) asInt - (S['I2]) asInt] .
  eq eval($builtin("*"), S, CN, N) = "int"[(S['I1]) asInt * (S['I2]) asInt] .
  eq eval($builtin("/"), S, CN, N) = "int"[(S['I1]) asInt quo (S['I2]) asInt] .
  eq eval($builtin("%"), S, CN, N) = "int"[(S['I1]) asInt rem (S['I2]) asInt] .
  eq eval($builtin("<"), S, CN, N) = ((S['I1]) asInt < (S['I2]) asInt) asAbsBool .
  eq eval($builtin("<="), S, CN, N) = ((S['I1]) asInt <= (S['I2]) asInt) asAbsBool .
  eq eval($builtin(">"), S, CN, N) = ((S['I1]) asInt > (S['I2]) asInt) asAbsBool .
  eq eval($builtin(">="), S, CN, N) = ((S['I1]) asInt >= (S['I2]) asInt) asAbsBool .
  *** ABS-DATA-STRING
  ceq eval($builtin("+"), S, CN, N) = "str"[I1:String + I2:String]
  if "str"[I1:String] := S['I1] /\ "str"[I2:String] := S['I2] .
  eq eval($builtin("substr"), S, CN, N) =
    "str"[substr((S['S]) asString, (S['L]) asInt, (S['R]) asInt)] .
  eq eval($builtin("strlen"), S, CN, N) =
    "int"[length((S['S]) asString)] .
  *** ABS-DATA-TIME
  --- N will be 0 in the untimed case.
  eq eval($builtin("currentms"), S, CN, N) = "int"[N] .

endm

mod ABS-MSG-TRANSPORT is
  protecting ABS-CONFIGURATION .

  vars M CG : String .   var MIS : MMtd .              vars AL AL' : VidList .
  vars S S1 L : Subst .  var SL : StmtList .           var N : Label .
  var DL : DataList .    var C : Cid .                 var DeL : DeltaList .
  vars F G : Nat .       vars O O1 : Oid .             var P : Process .
  var W : MProc .        var MI : Method .             var D : Did .
  var MS : StringSet .   var CMS : ClassModifierSet .  var B : Bool .
  var SS : SSubst .



  --- This is used in the original() call to set the search starting point.
  op pruneDeltaList : DeltaList Did -> DeltaList .
  eq pruneDeltaList(noDelta, DE:Did) = noDelta .
  eq pruneDeltaList(DeL:DeltaList DE:Did, DE:Did) = DeL:DeltaList .
  ceq pruneDeltaList(DeL:DeltaList DE1:Did, DE:Did) = pruneDeltaList(DeL:DeltaList, DE:Did)
  if DE1:Did =/= DE:Did .

  --- message generation
  eq
    < O1 : C | Cog: CG, Att: S, Pr: { L | $call(N ; O ; M ; DL ; B) ; SL }, PrQ: W, Lcnt: F > 
  =
    < O1 : C | Cog: CG, Att: S, Pr: { L | SL }, PrQ: W, Lcnt: (s F) >
    invoc(O, N, M, DL, B)
      [label call-internal] .
  

  --- transport
  ---
  --- Receive an invocation message to bind the method body.  We never make
  --- this a rule -- scheduling is done elsewhere.
  ---
  eq
    < O : C | Cog: CG, Att: S, Pr: P, PrQ: W, Lcnt: F >
    < C : Class | Deltas: DeL, Param: AL, Att: S1 , Mtds: MIS , Ocnt: G >
    invoc(O, N, M, DL, B)
  =
    findMethod(M, C, DeL, N, O, DL, B)
    < O : C | Cog: CG, Att: S, Pr: P, PrQ: W, Lcnt: F >
    < C : Class | Deltas: DeL, Param: AL, Att: S1 , Mtds: MIS , Ocnt: G >
    [label transport-imsg] .

  --- Look up a method in the deltas of a class and the class itself.
  eq
    findMethod(M, C, noDelta, N, O, DL, B)
    < C : Class | Deltas: DeL, Param: AL', Att: S1 , 
                  Mtds: (MIS, < M : Method | Param: AL, Code: SL >),
                  Ocnt: G >
  =
    foundMethod(< M : Method | Param: AL, Code: SL >, "", N, O, DL, B)
    < C : Class | Deltas: DeL, Param: AL', Att: S1, 
                  Mtds: (MIS, < M : Method | Param: AL, Code: SL >),
                  Ocnt: G > .

  eq
    findMethod(M, C, (DeL D), N, O, DL, B)
    < D : Delta | addM(C, < M : Method | Param: AL, Code: SL >), CMS >
  =
    foundMethod(< M : Method | Param: AL, Code: SL >, D, N, O, DL, B)
    < D : Delta | addM(C, < M : Method | Param: AL, Code: SL >), CMS > .

  eq
    findMethod(M, C, (DeL D), N, O, DL, B)
    < D : Delta | removeM(C, M), CMS >
  =
    foundMethod(noMethod, D, N, O, DL, B)
    < D : Delta | removeM(C, M), CMS > .

  eq
    findMethod(M, C, (DeL D), N, O, DL, B)
    < D : Delta | CMS >
  =
    findMethod(M, C, DeL, N, O, DL, B)
    < D : Delta | CMS > [owise] . 

  --- Create a process from a method invocation once the method has been found.
  eq
    < O : C | Cog: CG, Att: S1, Pr: P, PrQ: W, Lcnt: F >
    foundMethod(< M : Method | Param: AL, Code: SL >, D, N, O, DL, B)
  =
    < O : C | Cog: CG, Att: S1, Pr: P, PrQ: (W, makeProcess(< M : Method | Param: AL, Code: SL >, D, N, DL, B)), Lcnt: F >
    < N : Future | Name: M, Completed: false, References: 1, Value: null >
    [label transport-imsg-2] .

  eq makeProcess(< M : Method | Param: AL, Code: SL >, D, N, DL, B)
  =
    { '.label |-> N, '.method |-> "str"[ M ], '.delta |-> "str"[D], '.staticfuture |-> null, '_ |-> null, createSubst(AL, DL) | SL ; if B then $cont(N) else noStmt fi } .

endm


*** The machine.
***
*** We have one module per statement per evaluation strategy, and combine them
*** in the end.


*** Some common functionality: scheduling, trivial statements that are always
*** equations, etc.
mod ABS-MACHINE-BASICS is
  protecting ABS-EVAL .
  protecting ABS-MSG-TRANSPORT .

  vars O O1 : Oid .         vars C B : Cid .     vars S S1 L L1 : Subst .
  vars SL SL1 : StmtList .  vars W W1 : MProc .  vars F G X : Nat .
  var CN : Configuration .  var P : Process .    vars A A' : Vid .
  var E : Expr .            var AL : VidList .   var N : Label .
  vars Q CG : String .      var MS : MMtd .      var CO : Bool .
  var D : Data .            var DL : DataList .  var S2 : SSubst .
  var DeL : DeltaList .

  --- Schedule a new process for execution, if it is ready.
  ---
  --- Must be a rule to preserve confluence.
  ---
  --- We capture the entire state here since the condition E can depend on the
  --- state of Futures contained in CN.
  crl
    { < CG : Cog | Object: null >
      < O : C | Cog: CG, Att: S, Pr: idle, PrQ: W , { L | SL }, Lcnt: F > CN  }
  =>
    { < CG : Cog | Object: O >
      < O : C | Cog: CG, Att: S, Pr: { L | SL }, PrQ: W, Lcnt: F > CN  }
  if ready(SL, (S :: L), CN, 0)
      [label PrQ-ready] .

  --- Processes that end release the Cog.
  eq
    < CG : Cog | Object: O >
    < O : C | Cog: CG, Att: S, Pr: { L | noStmt }, PrQ: W, Lcnt: F >
  =
    < CG : Cog | Object: null >
    < O : C | Cog: CG, Att: S, Pr: idle, PrQ: W, Lcnt: F >
    [label Process-terminate] .

  *** Handle synchronous calls within cogs.
  *** 
  *** Only schedule the process if it is ready - so we have to capture the
  *** entire state here as well.
  ceq
    { < CG : Cog | Object: O >
      < O : C | Cog: CG, Att: S, Pr: { L | get(A ; A') ; SL }, PrQ: W, Lcnt: F >
      < O1 : B | Cog: CG, Att: S1, Pr: idle, PrQ: W1 , { L1 | SL1 }, Lcnt: G >
      CN
    }
  =
    { < CG : Cog | Object: O1 >
      < O : C | Cog: CG, Att: S, Pr: idle, PrQ: W, { L | get(A ; A') ; SL }, Lcnt: F >
      < O1 : B | Cog: CG, Att: S1, Pr: { L1 | SL1 }, PrQ: W1 , Lcnt: G >
      CN
    }
    *** L[A] because synchronous calls are always handled via ".staticfuture"
  if  L[A] == L1['.label] /\ ready(SL1, (S1 :: L1), CN, 0)
    [label schedule-cog] .

  *** Handle synchronous self-calls
  ceq
    < O : C | Cog: CG, Att: S, Pr: { L | get(A ; A') ; SL }, PrQ: W, {L1 | SL1}, Lcnt: F >
  =
    < O : C | Cog: CG, Att: S, Pr: {L1 | SL1}, PrQ: W, { L | get(A ; A') ; SL }, Lcnt: F >
    *** L[A] because synchronous calls are always handled via ".staticfuture"
  if  L[A] == L1['.label]
    [label schedule-self] .

  --- mark
  ---
  --- Mark a label in use.  We don't bother to make this a rule until we need
  --- it.
  ceq
    < O : C | Cog: CG, Att: S, Pr: { L | $mark(E) ; SL }, PrQ: W, Lcnt: F >
    < N : Future | Name: Q, Completed: CO, References: G, Value: D >
  =
    < O : C | Cog: CG, Att: S, Pr: { L | SL }, PrQ: W, Lcnt: F >
    < N : Future | Name: Q, Completed: CO, References: G + 1, Value: D >
  if N := eval(E, (S :: L), none, 0)
      [label mark] .

  --- free
  ---
  --- Free a Future.
  ---
  ceq
    < O : C | Cog: CG, Att: S, Pr: { L | $free(E) ; SL }, PrQ: W, Lcnt: F >
    < N : Future | Name: Q, Completed: CO, References: G, Value: D >
  =
    < O : C | Cog: CG, Att: S, Pr: { L | SL }, PrQ: W, Lcnt: F >
    < N : Future | Name: Q, Completed: CO, 
                   References: if G == 0 then 0 else sd(G, 1) fi,
                   Value: D >
  if N := eval(E, (S :: L), none, 0)
      [label free] .

  --- Skip the $free instruction if the variable is uninitialized.  This helps
  --- the code generator.
  ceq
    < O : C | Cog: CG, Att: S, Pr: { L | $free(A) ; SL }, PrQ: W, Lcnt: F >
  =
    < O : C | Cog: CG, Att: S, Pr: { L | SL }, PrQ: W, Lcnt: F >
  if null = (S :: L)[A]
      [label free-uninitialized] .

  --- Completed futures without references can be removed.
  ---
  eq < N : Future | Name: Q, Completed: true, References: 0, Value: D > = none .

  --- Create a new environment.  This is for supporting local declarations in
  --- blocks etc.
  eq
    < O : C | Cog: CG, Att: S, Pr: { L | $beginscope ; SL }, PrQ: W, Lcnt: F >
  =
    < O : C | Cog: CG, Att: S, Pr: { L :: noSubst | SL }, PrQ: W, Lcnt: F >
    [label $beginscope] .

  --- Introduce a new variable into the local scope.
  eq
    < O : C | Cog: CG, Att: S, Pr: { L | $vardecl( A ; E ) ; SL}, PrQ: W, Lcnt: F >
  =
    < O : C | Cog: CG, Att: S, Pr: { insert(A, eval(E, (S :: L), none, 0), L) | SL }, PrQ: W, Lcnt: F >
    [label $vardecl] .

  eq
    < O : C | Cog: CG, Att: S, Pr: { L :: S2 | $endscope ; SL }, PrQ: W, Lcnt: F >
  =
    < O : C | Cog: CG, Att: S, Pr: { L | SL }, PrQ: W, Lcnt: F >
    [label $endscope-1] .
  eq
    < O : C | Cog: CG, Att: S, Pr: { S2 | $endscope ; SL }, PrQ: W, Lcnt: F >
  =
    *** Shouldn't happen, but can't harm
    < O : C | Cog: CG, Att: S, Pr: { S2 | SL }, PrQ: W, Lcnt: F >
    [label $endscope-2] .


  --- assert
  ---
  eq
    { < O : C | Cog: CG, Att: S, Pr: { L | assert(E) ; SL }, PrQ: W, Lcnt: F > CN  }
  =
    { if eval(E, (S :: L), CN, 0) asBool then
        < O : C | Cog: CG, Att: S, Pr: { L | SL }, PrQ: W, Lcnt: F >
      else
        < O : C | Cog: CG, Att: S, Pr: { L | failure(E) ; SL }, PrQ: W, Lcnt: F >
      fi CN  }
    [label assert] .
endm
mod ABS-MACHINE-BASICS-TIMED is
  protecting ABS-EVAL .
  protecting ABS-MSG-TRANSPORT .

  vars O O1 : Oid .         vars C B : Cid .     vars S S1 L L1 : Subst .
  vars SL SL1 : StmtList .  vars W W1 : MProc .  vars F G : Nat .
  var CN : Configuration .  var P : Process .    vars A A' : Vid .
  var E : Expr .            var AL : VidList .   var N : Label .
  vars Q CG : String .      var MS : MMtd .      var CO : Bool .
  var D : Data .            var DL : DataList .  var S2 : SSubst .
  vars T LIM : Nat .        var DeL : DeltaList .

  --- Schedule a new process for execution, if it is ready.
  ---
  --- Must be a rule to preserve confluence.
  ---
  --- We capture the entire state here since the condition E can depend on the
  --- state of Futures contained in CN.
  crl
    { < CG : Cog | Object: null >
      < O : C | Cog: CG, Att: S, Pr: idle, PrQ: W , { L | SL }, Lcnt: F >
      < T : Clock | Limit: LIM >
      CN  }
  =>
    { < CG : Cog | Object: O >
      < O : C | Cog: CG, Att: S, Pr: { L | SL }, PrQ: W, Lcnt: F >
      < T : Clock | Limit: LIM >
      CN  }
  if ready(SL, (S :: L), CN, T)
      [label PrQ-ready] .

  --- Processes that end release the Cog.
  eq
    < CG : Cog | Object: O >
    < O : C | Cog: CG, Att: S, Pr: { L | noStmt }, PrQ: W, Lcnt: F >
  =
    < CG : Cog | Object: null >
    < O : C | Cog: CG, Att: S, Pr: idle, PrQ: W, Lcnt: F >
    [label Process-terminate] .

  *** Handle synchronous calls within cogs.
  *** 
  *** Only schedule the process if it is ready - so we have to capture the
  *** entire state here as well.
  ceq
    { < CG : Cog | Object: O >
      < O : C | Cog: CG, Att: S, Pr: { L | get(A ; A') ; SL }, PrQ: W, Lcnt: F >
      < O1 : B | Cog: CG, Att: S1, Pr: idle, PrQ: W1 , { L1 | SL1 }, Lcnt: G >
      < T : Clock | Limit: LIM >
      CN
    }
  =
    { < CG : Cog | Object: O1 >
      < O : C | Cog: CG, Att: S, Pr: idle, PrQ: W, { L | get(A ; A') ; SL }, Lcnt: F >
      < O1 : B | Cog: CG, Att: S1, Pr: { L1 | SL1 }, PrQ: W1 , Lcnt: G >
      < T : Clock | Limit: LIM >
      CN
    }
    *** L[A] because synchronous calls are always handled via ".staticfuture"
  if  L[A] == L1['.label] /\ ready(SL1, (S1 :: L1), CN, T)
    [label schedule-cog] .

  *** Handle synchronous self-calls
  ceq
    < O : C | Cog: CG, Att: S, Pr: { L | get(A ; A') ; SL }, PrQ: W, {L1 | SL1}, Lcnt: F >
  =
    < O : C | Cog: CG, Att: S, Pr: {L1 | SL1}, PrQ: W, { L | get(A ; A') ; SL }, Lcnt: F >
    *** L[A] because synchronous calls are always handled via ".staticfuture"
  if  L[A] == L1['.label]
    [label schedule-self] .

  --- mark
  ---
  --- Mark a label in use.  We don't bother to make this a rule until we need
  --- it.
  ceq
    < O : C | Cog: CG, Att: S, Pr: { L | $mark(E) ; SL }, PrQ: W, Lcnt: F >
    < N : Future | Name: Q, Completed: CO, References: G, Value: D >
    < T : Clock | Limit: LIM >
  =
    < O : C | Cog: CG, Att: S, Pr: { L | SL }, PrQ: W, Lcnt: F >
    < N : Future | Name: Q, Completed: CO, References: G + 1, Value: D >
    < T : Clock | Limit: LIM >
  if N := eval(E, (S :: L), none, T)
      [label mark] .

  --- free
  ---
  --- Free a Future.
  ---
  ceq
    < O : C | Cog: CG, Att: S, Pr: { L | $free(E) ; SL }, PrQ: W, Lcnt: F >
    < N : Future | Name: Q, Completed: CO, References: G, Value: D >
    < T : Clock | Limit: LIM >
  =
    < O : C | Cog: CG, Att: S, Pr: { L | SL }, PrQ: W, Lcnt: F >
    < N : Future | Name: Q, Completed: CO, 
                   References: if G == 0 then 0 else sd(G, 1) fi,
                   Value: D >
    < T : Clock | Limit: LIM >
  if N := eval(E, (S :: L), none, T)
      [label free] .

  --- Skip the $free instruction if the variable is uninitialized.  This helps
  --- the code generator.
  ceq
    < O : C | Cog: CG, Att: S, Pr: { L | $free(A) ; SL }, PrQ: W, Lcnt: F >
  =
    < O : C | Cog: CG, Att: S, Pr: { L | SL }, PrQ: W, Lcnt: F >
  if null = (S :: L)[A]
      [label free-uninitialized] .

  --- Completed futures without references can be removed.
  ---
  eq < N : Future | Name: Q, Completed: true, References: 0, Value: D > = none .

  --- Create a new environment.  This is for supporting local declarations in
  --- blocks etc.
  eq
    < O : C | Cog: CG, Att: S, Pr: { L | $beginscope ; SL }, PrQ: W, Lcnt: F >
  =
    < O : C | Cog: CG, Att: S, Pr: { L :: noSubst | SL }, PrQ: W, Lcnt: F >
    [label $beginscope] .

  --- Introduce a new variable into the local scope.
  eq
    < T : Clock | Limit: LIM >
    < O : C | Cog: CG, Att: S, Pr: { L | $vardecl( A ; E ) ; SL}, PrQ: W, Lcnt: F >
  =
    < T : Clock | Limit: LIM >
    < O : C | Cog: CG, Att: S, Pr: { insert(A, eval(E, (S :: L), none, T), L) | SL }, PrQ: W, Lcnt: F >
    [label $vardecl] .

  *** TODO: release labels that are going out of scope here.
  eq
    < O : C | Cog: CG, Att: S, Pr: { L :: S2 | $endscope ; SL }, PrQ: W, Lcnt: F >
  =
    < O : C | Cog: CG, Att: S, Pr: { L | SL }, PrQ: W, Lcnt: F >
    [label $endscope-1] .
  eq
    < O : C | Cog: CG, Att: S, Pr: { S2 | $endscope ; SL }, PrQ: W, Lcnt: F >
  =
    *** Shouldn't happen, but can't harm
    < O : C | Cog: CG, Att: S, Pr: { S2 | SL }, PrQ: W, Lcnt: F >
    [label $endscope-2] .


  --- assert
  ---
  eq
    { < O : C | Cog: CG, Att: S, Pr: { L | assert(E) ; SL }, PrQ: W, Lcnt: F >
      < T : Clock | Limit: LIM >
      CN  }
  =
    { if eval(E, (S :: L), CN, T) asBool then
        < O : C | Cog: CG, Att: S, Pr: { L | SL }, PrQ: W, Lcnt: F >
      else
        < O : C | Cog: CG, Att: S, Pr: { L | failure(E) ; SL }, PrQ: W, Lcnt: F >
      fi
      < T : Clock | Limit: LIM >
      CN  }
    [label assert] .

  *** Clock advancement.

  op noneready : MProc Subst Configuration Nat -> Bool .
  eq noneready((W, { L | SL }), S, CN, T) =
    not ready(SL, (S :: L), CN, T) and noneready(W, S, CN, T) .
  eq noneready(noProc, S, CN, T) = true .

  op canAdvance : Configuration Nat -> Bool .
  *** Block clock if a method invocation is on its way.
  eq canAdvance (m:Msg CN, T) = false .
  *** Block clock if object is idle but has processes that can be scheduled.
  eq canAdvance (
      < O : C | Cog: CG, Att: S, Pr: idle, PrQ: W, Lcnt: F > 
      CN, T) =
    noneready(W, S, CN, T) and canAdvance (CN, T) .
  *** Block clock if process is executing and can execute.
  eq canAdvance (
      < O : C | Cog: CG, Att: S, Pr: { L | SL }, PrQ: W, Lcnt: F >
      CN, T)
  =
    not(enabled(SL, (S :: L), CN, T)) and canAdvance(CN, T) .
  eq canAdvance(CN, T) = true [owise] .


  *** Now advance the clock.
  crl
    { CN < T : Clock | Limit: LIM > }
  =>
    { CN
      < T + 1 : Clock | Limit: LIM >  }
  if canAdvance (CN, T) and T < LIM
      [label tick] .

endm



*** The Skip statement.
mod ABS-STMT-SKIP-RL is
  protecting ABS-EVAL .

  var O : Oid .        var C : Cid .    vars S L : Subst .
  var SL : StmtList .  var W : MProc .  var F : Nat .
  var CG : String .

  rl
    < O : C | Cog: CG, Att: S, Pr: { L | skip ; SL }, PrQ: W, Lcnt: F >
  =>
    < O : C | Cog: CG, Att: S, Pr: { L | SL }, PrQ: W, Lcnt: F >
    [label skip] .
endm
mod ABS-STMT-SKIP-EQ is
  protecting ABS-EVAL .

  var O : Oid .        var C : Cid .    vars S L : Subst .
  var SL : StmtList .  var W : MProc .  var F : Nat .
  var CG : String .

  eq
    < O : C | Cog: CG, Att: S, Pr: { L | skip ; SL }, PrQ: W, Lcnt: F >
  =
    < O : C | Cog: CG, Att: S, Pr: { L | SL }, PrQ: W, Lcnt: F >
    [label skip] .
endm

*** The Assign statement.
  
*** Execute an assignment.  The expression on the right hand side of the
*** assignment is evaluated and stored as new value for the left hand side
*** identifier.
mod ABS-STMT-ASSIGN-RL is
  protecting ABS-EVAL .

  var O : Oid .        var C : Cid .    vars S L : Subst .
  var SL : StmtList .  var W : MProc .  var F : Nat .
  var E : Expr .       var D : Data .   var CG : String .
  var Q : Qid .

  *** Variable or field assignment
  crl
    < O : C | Cog: CG, Att: S, Pr: { L | assign(Q ; E) ; SL }, PrQ: W, Lcnt: F > 
  =>
    if hasMapping(L, Q) then
      < O : C | Cog: CG, Att: S, Pr: { update(Q, D, L) |  SL }, PrQ: W, Lcnt: F >
    else
      < O : C | Cog: CG, Att: insert(Q, D, S), Pr: { L | SL }, PrQ: W, Lcnt: F > 
    fi
    if D := eval(E, (S :: L), none, 0)
    [label assignment] .

  *** Field assignment
  crl
    < O : C | Cog: CG, Att: S, Pr: { L | assign(@ Q ; E) ; SL }, PrQ: W, Lcnt: F >
  =>
    < O : C | Cog: CG, Att: insert(Q, D, S), Pr: { L | SL }, PrQ: W, Lcnt: F >
  if D := eval(E, (S :: L), none, 0)
    [label field-assignment] .
endm
mod ABS-STMT-ASSIGN-EQ is
  protecting ABS-EVAL .
  var O : Oid .        var C : Cid .    vars S L : Subst .
  var SL : StmtList .  var W : MProc .  var F : Nat .
  var E : Expr .       var D : Data .   var CG : String .
  var Q : Qid .

  *** Variable or field assignment.
  ceq
    < O : C | Cog: CG, Att: S, Pr: { L | assign(Q ; E) ; SL }, PrQ: W, Lcnt: F > 
  =
    if hasMapping(L, Q) then
      < O : C | Cog: CG, Att: S, Pr: { update(Q, D, L) |  SL }, PrQ: W, Lcnt: F >
    else
      < O : C | Cog: CG, Att: insert(Q, D, S), Pr: { L | SL }, PrQ: W, Lcnt: F > 
    fi
    if D := eval(E, (S :: L), none, 0)
    [label assignment] .

  *** Field assignment.
  ceq
    < O : C | Cog: CG, Att: S, Pr: { L | assign(@ Q ; E) ; SL }, PrQ: W, Lcnt: F >
  =
    < O : C | Cog: CG, Att: insert(Q, D, S), Pr: { L | SL }, PrQ: W, Lcnt: F >
  if D := eval(E, (S :: L), none, 0)
    [label field-assignment] .
endm
mod ABS-STMT-ASSIGN-EQ-TIMED is
  protecting ABS-EVAL .
  var O : Oid .        var C : Cid .    vars S L : Subst .
  var SL : StmtList .  var W : MProc .  var F : Nat .
  var E : Expr .       var D : Data .   var CG : String .
  vars T LIM : Nat .   var Q : Qid .

  *** Variable or field assignment.
  ceq
    < T : Clock | Limit: LIM >
    < O : C | Cog: CG, Att: S, Pr: { L | assign(Q ; E) ; SL }, PrQ: W, Lcnt: F > 
  =
    < T : Clock | Limit: LIM >
    if hasMapping(L, Q) then
      < O : C | Cog: CG, Att: S, Pr: { update(Q, D, L) |  SL }, PrQ: W, Lcnt: F >
    else
      < O : C | Cog: CG, Att: insert(Q, D, S), Pr: { L | SL }, PrQ: W, Lcnt: F > 
    fi
    if D := eval(E, (S :: L), none, T)
    [label assignment] .

  *** Field assignment.
  ceq
    < T : Clock | Limit: LIM >
    < O : C | Cog: CG, Att: S, Pr: { L | assign(@ Q ; E) ; SL }, PrQ: W, Lcnt: F >
  =
    < T : Clock | Limit: LIM >
    < O : C | Cog: CG, Att: insert(Q, D, S), Pr: { L | SL }, PrQ: W, Lcnt: F >
  if D := eval(E, (S :: L), none, T)
    [label field-assignment] .
endm

*** The conditional (if_then_else) statement.
mod ABS-STMT-COND-RL is
  protecting ABS-EVAL .

  var O : Oid .                 var C : Cid .      vars S L : Subst .
  vars SL SL1 SL2 : StmtList .  var W : MProc .    var F : Nat .
  var E : Expr .                var CG : String .

  rl
    < O : C | Cog: CG, Att: S, Pr: { L | if E th SL1 el SL2 fi ; SL }, PrQ: W, Lcnt: F >
  =>
    if eval(E, (S :: L), none, 0) asBool then
      < O : C | Cog: CG, Att: S, Pr: { L | SL1 ; SL }, PrQ: W, Lcnt: F >
    else
      < O : C | Cog: CG, Att: S, Pr: { L | SL2 ; SL }, PrQ: W, Lcnt: F >
    fi
    [label if-then-else] .
endm
mod ABS-STMT-COND-EQ is
  protecting ABS-EVAL .

  var O : Oid .                 var C : Cid .      vars S L : Subst .
  vars SL SL1 SL2 : StmtList .  var W : MProc .    var F : Nat .
  var E : Expr .                var CG : String .

  eq
    < O : C | Cog: CG, Att: S, Pr: { L | if E th SL1 el SL2 fi ; SL }, PrQ: W, Lcnt: F >
  =
    if eval(E, (S :: L), none, 0) asBool then
      < O : C | Cog: CG, Att: S, Pr: { L | SL1 ; SL }, PrQ: W, Lcnt: F >
    else
      < O : C | Cog: CG, Att: S, Pr: { L | SL2 ; SL }, PrQ: W, Lcnt: F >
    fi
    [label if-then-else] .
endm
mod ABS-STMT-COND-EQ-TIMED is
  protecting ABS-EVAL .

  var O : Oid .                 var C : Cid .       vars S L : Subst .
  vars SL SL1 SL2 : StmtList .  var W : MProc .     var F : Nat .
  var E : Expr .                vars T LIM : Nat .  var CG : String .

  eq
    < T : Clock | Limit: LIM >
    < O : C | Cog: CG, Att: S, Pr: { L | if E th SL1 el SL2 fi ; SL }, PrQ: W, Lcnt: F >
  =
    < T : Clock | Limit: LIM >
    if eval(E, (S :: L), none, T) asBool then
      < O : C | Cog: CG, Att: S, Pr: { L | SL1 ; SL }, PrQ: W, Lcnt: F >
    else
      < O : C | Cog: CG, Att: S, Pr: { L | SL2 ; SL }, PrQ: W, Lcnt: F >
    fi
    [label if-then-else] .
endm

*** The looping (while) statement.
mod ABS-STMT-WHILE-RL is
  protecting ABS-EVAL .
  var O : Oid .             var C : Cid .      vars S L : Subst .
  vars SL SL1 : StmtList .  var W : MProc .    var F : Nat .
  var E : Expr .            var CG : String .

  rl
    < O : C | Cog: CG, Att: S, Pr: { L | while E do SL1 od ; SL }, PrQ: W, Lcnt: F >
  =>
    < O : C | Cog: CG, Att: S,
              Pr: { L | if E th (SL1 ; while E do SL1 od) el noStmt fi ; SL },
              PrQ: W, Lcnt: F >
    [label while] .
endm
mod ABS-STMT-WHILE-EQ is
  protecting ABS-EVAL .

  var O : Oid .             var C : Cid .      vars S L : Subst .
  vars SL SL1 : StmtList .  var W : MProc .    var F : Nat .
  var E : Expr .            var CG : String .

  eq
    < O : C | Cog: CG, Att: S, Pr: { L | while E do SL1 od ; SL }, PrQ: W, Lcnt: F >
  =
    < O : C | Cog: CG, Att: S,
              Pr: { L | if E th (SL1 ; while E do SL1 od) el skip fi ; SL },
              PrQ: W, Lcnt: F >
    [label while] .
endm

*** The Suspend statement.
***
*** The suspend statement is an unconditional processor release point.
mod ABS-STMT-SUSPEND-RL is
  protecting ABS-EVAL .

  var O : Oid .        var C : Cid .    vars S L : Subst .
  var SL : StmtList .  var W : MProc .  var F : Nat .
  var CG : String .

  rl
    < CG : Cog | Object: O >
    < O : C | Cog: CG, Att: S, Pr: { L | suspend ; SL }, PrQ: W, Lcnt: F >
  =>
    < CG : Cog | Object: null >
    < O : C | Cog: CG, Att: S, Pr: idle, PrQ: W , { L | SL }, Lcnt: F >
    [label suspend] .
endm
mod ABS-STMT-SUSPEND-EQ is
  protecting ABS-EVAL .

  var O : Oid .        var C : Cid .    vars S L : Subst .
  var SL : StmtList .  var W : MProc .  var F : Nat .
  var CG : String .

  eq
    < CG : Cog | Object: O >
    < O : C | Cog: CG, Att: S, Pr: { L | suspend ; SL }, PrQ: W, Lcnt: F >
  =
    < CG : Cog | Object: null >
    < O : C | Cog: CG, Att: S, Pr: idle, PrQ: W , { L | SL }, Lcnt: F >
    [label suspend] .
endm

*** The Await statement.
  
*** These rules capture the entire state CN since the condition E can depend
*** on the state of Futures (and therefore CN needs to be passed to
*** "enabled").
mod ABS-STMT-AWAIT-RL is
  protecting ABS-EVAL .

  var O : Oid .             var C : Cid .    vars S L : Subst .
  var SL : StmtList .       var W : MProc .  var F : Nat .
  var CN : Configuration .  var E : Expr .   vars Q CG : String .

  rl
    { < CG : Cog | Object: O >
      < O : C | Cog: CG, Att: S, Pr: { L | await E ; SL }, PrQ: W, Lcnt: F >
      CN  }
  =>
    if enabled(await E, (S :: L), CN, 0) then
      { < CG : Cog | Object: O >
        < O : C | Cog: CG, Att: S, Pr: { L | SL }, PrQ: W, Lcnt: F >
        CN  }
    else
      { < CG : Cog | Object: null >
        < O : C | Cog: CG, Att: S, Pr: idle, PrQ: W , { L | await E ; SL}, Lcnt: F > 
        CN  }
    fi
      [label await] .
endm
mod ABS-STMT-AWAIT-EQ is
  protecting ABS-EVAL .

  var O : Oid .             var C : Cid .    vars S L : Subst .
  var SL : StmtList .       var W : MProc .  var F : Nat .
  var CN : Configuration .  var E : Expr .   vars Q CG : String .

  eq
    { < CG : Cog | Object: O >
      < O : C | Cog: CG, Att: S, Pr: { L | await E ; SL }, PrQ: W, Lcnt: F >
      CN  }
  =
    if enabled(await E, (S :: L), CN, 0) then
      { < CG : Cog | Object: O >
        < O : C | Cog: CG, Att: S, Pr: { L | SL }, PrQ: W, Lcnt: F >
        CN  }
    else
      { < CG : Cog | Object: null >
        < O : C | Cog: CG, Att: S, Pr: idle, PrQ: W , { L | await E ; SL}, Lcnt: F > 
        CN  }
    fi
      [label await] .
endm
mod ABS-STMT-AWAIT-EQ-TIMED is
  protecting ABS-EVAL .

  var O : Oid .             var C : Cid .    vars S L : Subst .
  var SL : StmtList .       var W : MProc .  var F : Nat .
  var CN : Configuration .  var E : Expr .   vars Q CG : String .
  vars T LIM : Nat .

  eq
    { < CG : Cog | Object: O >
      < O : C | Cog: CG, Att: S, Pr: { L | await E ; SL }, PrQ: W, Lcnt: F >
      < T : Clock | Limit: LIM >
      CN  }
  =
    if enabled(await E, (S :: L), CN, T) then
      { < CG : Cog | Object: O >
        < O : C | Cog: CG, Att: S, Pr: { L | SL }, PrQ: W, Lcnt: F >
        < T : Clock | Limit: LIM >
        CN  }
    else
      { < CG : Cog | Object: null >
        < O : C | Cog: CG, Att: S, Pr: idle, PrQ: W , { L | await E ; SL}, Lcnt: F > 
        < T : Clock | Limit: LIM >
        CN  }
    fi
      [label await] .
endm

*** METHOD CALLS
mod ABS-CALLSTMTS-RL is
  protecting ABS-EVAL .
  protecting ABS-MSG-TRANSPORT .

  vars O O1 : Oid .            var C : Cid .        vars S S1 L : Subst .
  var SL : StmtList .          var W : MProc .      vars F G : Nat .
  var CN : Configuration .     var E : Expr .       vars Q CG M : String .
  var A : Vid .                var EL : ExprList .  var AL : VidList .
  var N : Label .              var DL : DataList .  var MS : MMtd .
  vars DeL DeL1 : DeltaList .  vars DE DE1 : Did .  var SS : SSubst .
  var MIS : MMtd .

  --- async-call
  ---
  crl
    < O : C | Cog: CG, Att: S, Pr: { L | asynccall(A ; E ; Q ; EL); SL }, PrQ: W, Lcnt: F > 
  =>
    < O : C | Cog: CG, Att: S, Pr: { L | assign(A ; N) ; $call(N ; O1 ; Q ; DL ; false) ; SL }, PrQ: W, Lcnt: (s F) > 
  if DL :=  evalList(EL, (S :: L), none, 0)
      /\ O1 := eval(E, (S :: L), none, 0)
      /\ N := label(O, F)
      [label async-call] .

  --- sync-call
  ---
  --- TODO: check whether target is in the same cog
  crl
    < O : C | Cog: CG, Att: S, Pr: { L | synccall(A ; E ; Q ; EL); SL }, PrQ: W, Lcnt: F > 
  =>
    < O : C | Cog: CG, Att: S, Pr: { L | assign(A ; N) ; $call(N ; O1 ; Q ; DL ; true) ; SL }, PrQ: W, Lcnt: (s F) > 
  if DL :=  evalList(EL, (S :: L), none, 0)
      /\ O1 := eval(E, (S :: L), none, 0)
      /\ N := label(O, F)
      [label sync-call] .

  --- original-call
  ---
  crl
    < O : C | Cog: CG, Att: S, Pr: { L | original(A ; EL); SL }, PrQ: W, Lcnt: F > 
    < C : Class | Deltas: DeL, Param: AL, Att: S1 , Mtds: MIS, Ocnt: G >
  =>
    < O : C | Cog: CG, Att: S, Pr: { L | assign('.staticfuture ; N); get('.staticfuture ; A) ; $free('.staticfuture) ; SL }, PrQ: W, Lcnt: (s F) > 
    < C : Class | Deltas: DeL, Param: AL, Att: S1 , Mtds: MIS, Ocnt: G >
    findMethod(M, C, pruneDeltaList(DeL, DE), N, O, evalList(EL, (S :: L), none, 0), true)
  if N := label(O, F)
      /\ "str"[M] := L['.method]
      /\ "str"[DE] := L['.delta]
      [label original-call] .
endm  
mod ABS-CALLSTMTS-EQ is
  protecting ABS-EVAL .
  protecting ABS-MSG-TRANSPORT .

  vars O O1 : Oid .         var C : Cid .        vars S S1 L : Subst .
  var SL : StmtList .       var W : MProc .      vars F G : Nat .
  var CN : Configuration .  var E : Expr .       vars Q CG M : String .
  var A : Vid .             var EL : ExprList .  var AL : VidList .
  var N : Label .           var DL : DataList .  var MS : MMtd .
  vars DeL DeL1 : DeltaList .  vars DE DE1 : Did .  var SS : SSubst .
  var MIS : MMtd .

  --- async-call
  ---
  ceq
    < O : C | Cog: CG, Att: S, Pr: { L | asynccall(A ; E ; Q ; EL) ; $call(N ; O1 ; Q ; DL ; false); SL }, PrQ: W, Lcnt: F > 
  =
    < O : C | Cog: CG, Att: S, Pr: { L | assign(A ; N) ; SL }, PrQ: W, Lcnt: (s F) > 
  if DL :=  evalList(EL, (S :: L), none, 0)
      /\ O1 := eval(E, (S :: L), none, 0)
      /\ N := label(O, F)
      [label async-call] .

  --- sync-call
  ---
  --- TODO: check whether target is in the same cog
  ceq
    < O : C | Cog: CG, Att: S, Pr: { L | synccall(A ; E ; Q ; EL); SL }, PrQ: W, Lcnt: F > 
  =
    < O : C | Cog: CG, Att: S, Pr: { L | assign(A ; N) ; $call(N ; O1 ; Q ; DL ; true) ; SL }, PrQ: W, Lcnt: (s F) > 
  if DL :=  evalList(EL, (S :: L), none, 0)
      /\ O1 := eval(E, (S :: L), none, 0)
      /\ N := label(O, F)
      [label sync-call] .

  --- original-call
  ---
  ceq
    < O : C | Cog: CG, Att: S, Pr: { L | original(A ; EL); SL }, PrQ: W, Lcnt: F > 
    < C : Class | Deltas: DeL, Param: AL, Att: S1 , Mtds: MIS, Ocnt: G >
  =
    < O : C | Cog: CG, Att: S, Pr: { L | assign(A ; N); SL }, PrQ: W, Lcnt: (s F) > 
    < C : Class | Deltas: DeL, Param: AL, Att: S1 , Mtds: MIS, Ocnt: G >
    findMethod(M, C, pruneDeltaList(DeL, DE), N, O, evalList(EL, (S :: L), none, 0), true)
  if N := label(O, F)
      /\ "str"[M] := L['.method]
      /\ "str"[DE] := L['.delta]
      [label original-call] .
endm
mod ABS-CALLSTMTS-EQ-TIMED is
  protecting ABS-EVAL .
  protecting ABS-MSG-TRANSPORT .

  vars O O1 : Oid .            var C : Cid .         vars S S1 L : Subst .
  var SL : StmtList .          var W : MProc .       vars F G : Nat .
  var CN : Configuration .     var E : Expr .        vars Q CG M : String .
  var A : Vid .                var EL : ExprList .   var AL : VidList .
  var N : Label .              var DL : DataList .   var MS : MMtd .
  vars T LIM : Nat .           var SS : SSubst .     var MIS : MMtd .
  vars DeL DeL1 : DeltaList .  vars DE DE1 : Did .
  --- async-call
  ---
  ceq
    < T : Clock | Limit: LIM >
    < O : C | Cog: CG, Att: S, Pr: { L | asynccall(A ; E ; Q ; EL) ; SL }, PrQ: W, Lcnt: F > 
  =
    < T : Clock | Limit: LIM >
    < O : C | Cog: CG, Att: S, Pr: { L | assign(A ; N) ; $call(N ; O1 ; Q ; DL ; false) ; SL }, PrQ: W, Lcnt: (s F) > 
  if DL :=  evalList(EL, (S :: L), none, T)
      /\ O1 := eval(E, (S :: L), none, T)
      /\ N := label(O, F)
      [label async-call] .

  --- sync-call
  ---
  --- TODO: check whether target is in the same cog
  ceq
    < T : Clock | Limit: LIM >
    < O : C | Cog: CG, Att: S, Pr: { L | synccall(A ; E ; Q ; EL) ; SL }, PrQ: W, Lcnt: F > 
  =
    < T : Clock | Limit: LIM >
    < O : C | Cog: CG, Att: S, Pr: { L | assign(A ; N) ; $call(N ; O1 ; Q ; DL ; true) ; SL }, PrQ: W, Lcnt: (s F) > 
  if DL :=  evalList(EL, (S :: L), none, T)
      /\ O1 := eval(E, (S :: L), none, T)
      /\ N := label(O, F)
      [label sync-call] .

  --- original-call
  ---
  ceq
    < T : Clock | Limit: LIM >
    < O : C | Cog: CG, Att: S, Pr: { L | original(A ; EL); SL }, PrQ: W, Lcnt: F > 
    < C : Class | Deltas: DeL, Param: AL, Att: S1 , Mtds: MIS, Ocnt: G >
  =
    < T : Clock | Limit: LIM >
    < O : C | Cog: CG, Att: S, Pr: { L | assign(A ; N); SL }, PrQ: W, Lcnt: (s F) > 
    < C : Class | Deltas: DeL, Param: AL, Att: S1 , Mtds: MIS, Ocnt: G >
    findMethod(M, C, pruneDeltaList(DeL, DE), N, O, evalList(EL, (S :: L), none, T), true)
  if N := label(O, F)
      /\ "str"[M] := L['.method]
      /\ "str"[DE] := L['.delta]
      [label original-call] .
endm


*** OBJECT CREATION
  
*** Also start the ".init" method.
mod ABS-NEW-RL is
  protecting ABS-EVAL .
  protecting ABS-MSG-TRANSPORT .

  var O : Oid .        vars B C : Cid .  vars S S1 L : Subst .
  var SL : StmtList .  var W : MProc .   vars F G : Nat .
  var E : Expr .       var A : Vid .     var EL : ExprList .
  var AL : VidList .   var MS : MMtd .   var DeL : DeltaList .
  var CG : String .

  rl
    < O : C | Cog: CG, Att: S, Pr: { L | new(A ; B ; EL); SL }, PrQ: W, Lcnt: F >
    < B : Class | Deltas: DeL, Param: AL, Att: S1, Mtds: MS, Ocnt: G >
  =>
    *** Here we get to write the whole synchronous invocation /
    *** synchronization protocol by hand (normally it is generated by the code
    *** generator)
    < O : C | Cog: CG, Att: S, Pr: { L | assign(A ; ob(newId(B, G))); synccall('.staticfuture ; ob(newId(B, G)) ; ".init" ; emp) ; get( '.staticfuture ; '_) ; $free('.staticfuture); SL }, PrQ: W,
              Lcnt: F >
    < B : Class | Deltas: DeL, Param: AL, Att: S1, Mtds: MS, Ocnt: (s G) >
    < ob(newId(B, G)) :  B | Cog: CG, Att: ('this |-> ob(newId(B, G)), S1,
                               createSubst(AL, evalList(EL, S :: L, none, 0))),
                             Pr: idle, PrQ: noProc, Lcnt: 0 >
    [label new-object] .

  rl
    < O : C | Cog: CG, Att: S, Pr: { L | newcog(A ; B ; EL); SL }, PrQ: W, Lcnt: F >
    < B : Class | Deltas: DeL, Param: AL, Att: S1, Mtds: MS, Ocnt: G >
  =>
    < O : C | Cog: CG, Att: S, Pr: { L | assign(A ; ob(newId(B, G))) ; asynccall('.staticfuture ; ob(newId(B, G)) ; ".init" ; emp) ; $free('.staticfuture) ; SL }, PrQ: W,
              Lcnt: F >
    < B : Class | Deltas: DeL, Param: AL, Att: S1, Mtds: MS, Ocnt: (s G) >
    < ob(newId(B, G)) :  B | Cog: newId(B, G), 
                             Att: ('this |-> ob(newId(B, G)), S1,
                               createSubst(AL, evalList(EL, S :: L, none, 0))),
                             Pr: idle, PrQ: noProc, Lcnt: 0 >
    < newId(B, G) : Cog | Object: null >
    [label new-object-with-cog] .
endm
mod ABS-NEW-EQ is
  protecting ABS-EVAL .
  protecting ABS-MSG-TRANSPORT .

  var O : Oid .        vars B C : Cid .  vars S S1 L : Subst .
  var SL : StmtList .  var W : MProc .   vars F G : Nat .
  var E : Expr .       var A : Vid .     var EL : ExprList .
  var AL : VidList .   var MS : MMtd .   var DeL : DeltaList .
  var CG : String .

  eq
    < O : C | Cog: CG, Att: S, Pr: { L | new(A ; B ; EL); SL }, PrQ: W, Lcnt: F >
    < B : Class | Deltas: DeL, Param: AL, Att: S1, Mtds: MS, Ocnt: G >
  =
    *** Here we get to write the whole synchronous invocation /
    *** synchronization protocol by hand (normally it is generated by the code
    *** generator)
    < O : C | Cog: CG, Att: S, Pr: { L | assign(A ; ob(newId(B, G))); synccall('.staticfuture ; ob(newId(B, G)) ; ".init" ; emp) ; get( '.staticfuture ; '_) ; $free('.staticfuture); SL }, PrQ: W,
              Lcnt: F >
    < B : Class | Deltas: DeL, Param: AL, Att: S1, Mtds: MS, Ocnt: (s G) >
    < ob(newId(B, G)) :  B | Cog: CG, Att: ('this |-> ob(newId(B, G)), S1,
                               createSubst(AL, evalList(EL, S :: L, none, 0))),
                             Pr: idle, PrQ: noProc, Lcnt: 0 >
    [label new-object] .

  eq
    < O : C | Cog: CG, Att: S, Pr: { L | newcog(A ; B ; EL); SL }, PrQ: W, Lcnt: F >
    < B : Class | Deltas: DeL, Param: AL, Att: S1, Mtds: MS, Ocnt: G >
  =
    < O : C | Cog: CG, Att: S, Pr: { L | assign(A ; ob(newId(B, G))) ; asynccall('.staticfuture ; ob(newId(B, G)) ; ".init" ; emp) ; $free('.staticfuture) ; SL }, PrQ: W,
              Lcnt: (s F) >
    < B : Class | Deltas: DeL, Param: AL, Att: S1, Mtds: MS, Ocnt: (s G) >
    < ob(newId(B, G)) :  B | Cog: newId(B, G),
                             Att: ('this |-> ob(newId(B, G)), S1,
                               createSubst(AL, evalList(EL, S :: L, none, 0))),
                             Pr: idle, PrQ: noProc, Lcnt: 0 >
    < newId(B, G) : Cog | Object: null >
    [label new-object-with-cog] .
endm
mod ABS-NEW-EQ-TIMED is
  protecting ABS-EVAL .
  protecting ABS-MSG-TRANSPORT .

  var O : Oid .        vars B C : Cid .   vars S S1 L : Subst .
  var SL : StmtList .  var W : MProc .    vars F G : Nat .
  var E : Expr .       var A : Vid .      var EL : ExprList .
  var AL : VidList .   var MS : MMtd .    var DeL : DeltaList .
  vars T LIM : Nat .   var CG : String .

  eq
    < T : Clock | Limit: LIM >
    < O : C | Cog: CG, Att: S, Pr: { L | new(A ; B ; EL); SL }, PrQ: W, Lcnt: F >
    < B : Class | Deltas: DeL, Param: AL, Att: S1, Mtds: MS, Ocnt: G >
  =
    *** Here we get to write the whole synchronous invocation /
    *** synchronization protocol by hand (normally it is generated by the code
    *** generator)
    < T : Clock | Limit: LIM >
    < O : C | Cog: CG, Att: S, Pr: { L | assign(A ; ob(newId(B, G))); synccall('.staticfuture ; ob(newId(B, G)) ; ".init" ; emp) ; get( '.staticfuture ; '_) ; $free('.staticfuture); SL }, PrQ: W,
              Lcnt: F >
    < B : Class | Deltas: DeL, Param: AL, Att: S1, Mtds: MS, Ocnt: (s G) >
    < ob(newId(B, G)) :  B | Cog: CG, Att: ('this |-> ob(newId(B, G)), S1,
                               createSubst(AL, evalList(EL, S :: L, none, 0))),
                             Pr: idle, PrQ: noProc, Lcnt: 0 >
    [label new-object] .

  eq
    < T : Clock | Limit: LIM >
    < O : C | Cog: CG, Att: S, Pr: { L | newcog(A ; B ; EL); SL }, PrQ: W, Lcnt: F >
    < B : Class | Deltas: DeL, Param: AL, Att: S1, Mtds: MS, Ocnt: G >
  =
    < T : Clock | Limit: LIM >
    < O : C | Cog: CG, Att: S, Pr: { L | assign(A ; ob(newId(B, G))) ; asynccall('.staticfuture ; ob(newId(B, G)) ; ".init" ; emp) ; $free('.staticfuture) ; SL }, PrQ: W,
              Lcnt: (s F) >
    < B : Class | Deltas: DeL, Param: AL, Att: S1, Mtds: MS, Ocnt: (s G) >
    < ob(newId(B, G)) :  B | Cog: newId(B, G),
                             Att: ('this |-> ob(newId(B, G)), S1,
                               createSubst(AL, evalList(EL, S :: L, none, T))),
                             Pr: idle, PrQ: noProc, Lcnt: 0 >
    < newId(B, G) : Cog | Object: null >
    [label new-object-with-cog] .
endm


*** The Return statement.
mod ABS-STMT-RETURN-RL is
  protecting ABS-EVAL .

  vars O : Oid .        var C : Cid .    vars S L : Subst .
  vars SL : StmtList .  var W : MProc .  vars F G : Nat .
  vars Q CG : String .  var N : Label .  var E : Expr .

  crl
    < O : C | Cog: CG, Att: S, Pr: { L | return(E); SL }, PrQ: W, Lcnt: F > 
    < N : Future | Name: Q, Completed: false, References: G, Value: null >
   =>
    *** NOTE (rs 2010-06-15) Note that a second return statement will deadlock
    *** the process.  We cannot return immediately since there might be
    *** `release' or `$endscope' statements after this, so we must rely on the
    *** compiler / type-checker to ascertain that there's one and only one
    *** return statement in each code branch.
    < O : C | Cog: CG, Att: S, Pr: { L | SL }, PrQ: W, Lcnt: F > 
    < N : Future | Name: Q, Completed: true, References: G, Value: eval(E, (S :: L), none, 0) >
  if N == L['.label]
      [label return] .
endm
mod ABS-STMT-RETURN-EQ is
  protecting ABS-EVAL .

  vars O : Oid .        var C : Cid .    vars S L : Subst .
  vars SL : StmtList .  var W : MProc .  vars F G : Nat .
  vars Q CG : String .  var N : Label .  var E : Expr .

  ceq
    < O : C | Cog: CG, Att: S, Pr: { L | return(E); SL }, PrQ: W, Lcnt: F > 
    < N : Future | Name: Q, Completed: false, References: G, Value: null >
   =
    *** NOTE (rs 2010-06-15) Note that a second return statement will deadlock
    *** the process.  We cannot return immediately since there might be
    *** `release' or `$endscope' statements after this, so we must rely on the
    *** compiler / type-checker to ascertain that there's one and only one
    *** return statement in each code branch.
    < O : C | Cog: CG, Att: S, Pr: { L | SL }, PrQ: W, Lcnt: F > 
    < N : Future | Name: Q, Completed: true, References: G, Value: eval(E, (S :: L), none, 0) >
  if N == L['.label]
      [label return] .
endm
mod ABS-STMT-RETURN-EQ-TIMED is
  protecting ABS-EVAL .

  vars O : Oid .        var C : Cid .    vars S L : Subst .
  vars SL : StmtList .  var W : MProc .  vars F G : Nat .
  vars Q CG : String .  var N : Label .  var E : Expr .
  vars T LIM : Nat .

  ceq
    < T : Clock | Limit: LIM >
    < O : C | Cog: CG, Att: S, Pr: { L | return(E); SL }, PrQ: W, Lcnt: F > 
    < N : Future | Name: Q, Completed: false, References: G, Value: null >
   =
    *** NOTE (rs 2010-06-15) Note that a second return statement will deadlock
    *** the process.  We cannot return immediately since there might be
    *** `release' or `$endscope' statements after this, so we must rely on the
    *** compiler / type-checker to ascertain that there's one and only one
    *** return statement in each code branch.
    < T : Clock | Limit: LIM >
    < O : C | Cog: CG, Att: S, Pr: { L | SL }, PrQ: W, Lcnt: F > 
    < N : Future | Name: Q, Completed: true, References: G, Value: eval(E, (S :: L), none, T) >
  if N == L['.label]
      [label return] .
endm


*** Receiving results from Futures.
***
*** Major source of nondeterminism and non-confluence if carelessly made into
*** equations, according to Creol interpreter.  We leave them as rules for
*** now.
mod ABS-RECEIVE-RESULT is
  protecting ABS-EVAL .

  vars O O1 : Oid .            vars B C : Cid .     vars S S1 L L1 : Subst .
  vars SL SL1 : StmtList .  vars W W1 : MProc .  vars F G X : Nat .
  vars Q CG : String .      vars A A' : Vid .    var N : Label .
  var D : Data .

  --- receive-comp
  ---
  --- Must be a rule even in the model checker, because there might be
  --- multiple completion messages with the same label but different return
  --- values in the queue.
  crl
    < O : C | Cog: CG, Att: S, Pr: { L | get(A ; A') ; SL }, PrQ: W, Lcnt: F >
    < N : Future | Name: Q, Completed: true, References: G, Value: D >
  =>
    < O : C | Cog: CG, Att: S, Pr: { L | assign(A' ; D) ; SL }, PrQ: W, Lcnt: F >
    < N : Future | Name: Q, Completed: true, References: G, Value: D >
  if N = (S :: L)[A]
    [label receive-comp-var] .


  --- continue
  ---
  --- Continue after executing the code of a local reply.  This is always a
  --- rule.  We want it to be a rule in the interpreter.
  --- 
  --- If we support shared futures, this must be a rule in the model
  --- checker, because there might be two processes in PrQ which await a
  --- reply to the label.
  crl
    < O : C | Cog: CG, Att: S, Pr: { L | $cont N }, PrQ: W , { L1 | get(A ; A') ; SL1},
              Lcnt: F >
  =>
    < O : C | Cog: CG, Att: S, Pr: { L1 | get(A ; A') ; SL1 }, PrQ: W,
              Lcnt: F >
  if N == L1[A]
    [label continue-self] .

  crl
    < O : C | Cog: CG, Att: S, Pr: { L | $cont label( O1 , X) }, PrQ: W, Lcnt: F >
    < CG : Cog | Object: O >
    < O1 : B | Cog: CG, Att: S1, Pr: idle, PrQ: W1 , { L1 | get(A ; A') ; SL1},
               Lcnt: G >
  =>
    < O : C | Cog: CG, Att: S, Pr: idle, PrQ: W, Lcnt: F >
    < CG : Cog | Object: O1 >
    < O1 : B | Cog: CG, Att: S1, Pr: { L1 | get(A ; A') ; SL1}, PrQ: W1 , Lcnt: G >
    *** not (S1 :: L1)[A] since synchronous calls always use .staticfuture to store the label.
  if label( O1 , X) == L1[A]
    [label continue-cog] .
endm

mod ABS-SIMULATOR-RL is
  --- A machine using rewrite rules.
  protecting ABS-MACHINE-BASICS .
  protecting ABS-STMT-SKIP-RL .
  protecting ABS-STMT-ASSIGN-RL .
  protecting ABS-STMT-COND-RL .
  protecting ABS-STMT-WHILE-RL .
  protecting ABS-STMT-SUSPEND-RL .
  protecting ABS-STMT-AWAIT-RL .
  protecting ABS-CALLSTMTS-RL .
  protecting ABS-NEW-RL .
  protecting ABS-STMT-RETURN-RL .
  protecting ABS-RECEIVE-RESULT .

  --- System initialisation with arbitrary class.  In Abs, the compiler will
  --- generate an operator "start" in the generated module that reduces to
  --- this, with an instantiation of the anonymous class implementing the
  --- block.  Still, this operator is useful by itself to create any active
  --- object by itself.
  op main : Configuration String DataList -> State .
  eq main(CN:Configuration, B:String, DL:DataList) =
    { CN:Configuration
      < "main" : Cog | Object: ob("main") >
      < ob("main") : "..." | Cog: "main", Att: noSubst, 
        Pr: { 'var |-> null, '.staticfuture |-> null | new('var ; B:String ; DL:DataList) },
        PrQ: noProc, Lcnt: 0 > } .

  --- The initial object commits suicide after it did its job.
  eq < ob("main") : "..." | Cog: "main", Att: S:Subst, Pr: idle, PrQ: noProc, Lcnt: 2 > =
    none .
endm

mod ABS-SIMULATOR-EQ is
  --- A machine using equations.
  protecting ABS-MACHINE-BASICS .
  protecting ABS-STMT-SKIP-EQ .
  protecting ABS-STMT-ASSIGN-EQ .
  protecting ABS-STMT-COND-EQ .
  protecting ABS-STMT-WHILE-EQ .
  protecting ABS-STMT-SUSPEND-EQ .
  protecting ABS-STMT-AWAIT-EQ .
  protecting ABS-CALLSTMTS-EQ .
  protecting ABS-NEW-EQ .
  protecting ABS-STMT-RETURN-EQ .
  protecting ABS-RECEIVE-RESULT .

  --- System initialisation with arbitrary class.  In Abs, the compiler will
  --- generate an operator "start" in the generated module that reduces to
  --- this, with an instantiation of the anonymous class implementing the
  --- block.  Still, this operator is useful by itself to create any active
  --- object by itself.
  op main : Configuration String DataList -> State .
  eq main(CN:Configuration, B:String, DL:DataList) =
    { CN:Configuration
      < "main" : Cog | Object: ob("main") >
      < ob("main") : "..." | Cog: "main", Att: noSubst, 
        Pr: { 'var |-> null, '.staticfuture |-> null | new('var ; B:String ; DL:DataList) },
        PrQ: noProc, Lcnt: 0 > } .

  --- The initial object commits suicide after it did its job.
  eq < ob("main") : "..." | Cog: "main", Att: S:Subst, Pr: idle, PrQ: noProc, Lcnt: 2 > =
    none .
endm

mod ABS-SIMULATOR-EQ-TIMED is
  --- A machine using equations, with an auto-advancing clock.
  protecting ABS-MACHINE-BASICS-TIMED .
  protecting ABS-STMT-SKIP-EQ .
  protecting ABS-STMT-ASSIGN-EQ-TIMED .
  protecting ABS-STMT-COND-EQ-TIMED .
  protecting ABS-STMT-WHILE-EQ .
  protecting ABS-STMT-SUSPEND-EQ .
  protecting ABS-STMT-AWAIT-EQ-TIMED .
  protecting ABS-CALLSTMTS-EQ-TIMED .
  protecting ABS-NEW-EQ-TIMED .
  protecting ABS-STMT-RETURN-EQ-TIMED .
  protecting ABS-RECEIVE-RESULT .

  --- System initialisation with arbitrary class.  In Abs, the compiler will
  --- generate an operator "start" in the generated module that reduces to
  --- this, with an instantiation of the anonymous class implementing the
  --- block.  Still, this operator is useful by itself to create any active
  --- object by itself.  This version also creates the global clock, with a
  --- limit arbitrarily chosen to be 100.
  op main : Configuration String DataList -> State .
  eq main(CN:Configuration, B:String, DL:DataList) =
    { CN:Configuration
      < 0 : Clock | Limit: 100 >
      < "main" : Cog | Object: ob("main") >
      < ob("main") : "..." | Cog: "main", Att: noSubst, 
        Pr: { 'var |-> null, '.staticfuture |-> null | new('var ; B:String ; DL:DataList) },
        PrQ: noProc, Lcnt: 0 > } .

  --- The initial object commits suicide after it did its job.
  eq < ob("main") : "..." | Cog: "main", Att: S:Subst, Pr: idle, PrQ: noProc, Lcnt: 2 > =
    none .
endm

eof

*** Local Variables:
*** maude-indent: 2
*** fill-column: 78
*** End:
