module Dining_Philosophers;
import * from ABS.StdLib;

type Fork = Int ;
type Available = Bool;

def B mylookup<A, B>(Map<A, B> ms, A k) = // retrieve from the map
  case ms {
     InsertAssoc(Pair(k, y), _) => y;
     // InsertAssoc(_, tm) => lookup(tm, k);
     // Rewritten for aPET (to avoid having fresh vars in the nomatch not present in the match)
     InsertAssoc(Pair(_, _), tm) => mylookup(tm, k);
  };

def Map<A, B> myput<A, B>(Map<A, B> ms, A k, B v) =
  case ms {
    EmptyMap => InsertAssoc(Pair(k, v),EmptyMap);
    InsertAssoc(Pair(k, _), ts) => InsertAssoc(Pair(k, v), ts);
    InsertAssoc(p, ts) => InsertAssoc(p, myput(ts, k, v));
  };


interface Tablei{
      Unit run();
      Unit request(Int n);
      Unit release(Int n);
}

interface Philosopheri{
      Unit run();
      Unit eat();
      Unit think();
}

interface Problemi{
      Unit run();
}

class ProblemImp(Int n) implements Problemi{
      Unit run(){
         Tablei tab = new TableImp(n);
         Fut<Unit> f = tab!run();
         await f?;
         Int i = 0;
         while(i < n){
             Philosopheri phi = new PhilosopherImp(n,i,tab);
             phi!run();
             i=i+1;
         }
      }
}
class TableImp(Int n) implements Tablei{
Map<Fork,Available> forks = EmptyMap;

    Unit run(){
        Int i = 0;
        while(i < n){
            this.forks = myput(this.forks,i,True);
            i=i+1;
        }
    }

    Unit request(Int i){
        await mylookup(this.forks,i);
        this.forks = myput(this.forks,i,False);
    }
    
    Unit release(Int i){
        this.forks = myput(this.forks,i,True);
    }
}

class PhilosopherImp(Int n,Int i,Tablei tab) implements Philosopheri{
     Unit run(){
         Int j = 0;
         while(j<n){
            Fut<Unit> f = tab!request(i);
            f.get;
            f = tab!request((i+1)%n);
            f.get;
            
//            f = this!eat();
//            await f?;
            
            tab!release(i);
            tab!release((i+1)%n);
           
//          f = this!think();
//           await f?;
            j=j+1;
         }
     }
     Unit eat(){}
     Unit think(){}
}

{
      Int n = 2;
      Problemi m = new ProblemImp(n);
      m!run(); 
}
