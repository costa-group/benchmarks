module DistHT;
import * from ABS.StdLib;

type Key = Int;
type Data = Int; 

def Int hash(Key k,Int n) = k%n;

//[k > 111][result() > 0]
def B mylookup<A, B>(Map<A, B> ms, A k) = // retrieve from the map
  case ms {
     InsertAssoc(Pair(k, y), _) => y;
     // InsertAssoc(_, tm) => lookup(tm, k);
     // Rewritten for aPET (to avoid having fresh vars in the nomatch not present in the match)
     InsertAssoc(Pair(_, _), tm) => mylookup(tm, k);
  };

def Map<A, B> myput<A, B>(Map<A, B> ms, A k, B v) =
  case ms {
    EmptyMap => InsertAssoc(Pair(k, v),EmptyMap);
    InsertAssoc(Pair(k, _), ts) => InsertAssoc(Pair(k, v), ts);
    // InsertAssoc(p, ts) => InsertAssoc(p, myput(ts, k, v));
    // Rewritten for aPET (to avoid having fresh vars in the nomatch not present in the match)
    InsertAssoc(Pair(kp,vp), ts) => InsertAssoc(Pair(kp,vp), myput(ts, k, v));
  };


interface DistHTInt{
    Maybe<Data> getData(Key key);
    List<Maybe<Data>> getAllData(List<Key> keys);
    Unit putData(Key key,Data d);
    NodeInt lookupNode(Key key);
    Set<Key> getAllKeys();
}

interface NodeInt{
    Maybe<Data> getData(Key key);
    Unit putData(Key key,Data d);
    Set<Key> getKeys();
}


class DistHT(List<NodeInt> nodes,Int nNodes) implements DistHTInt{

    [nodes <= max(nodes)][nNodes <= max(nNodes)]
    NodeInt lookupNode(Key key){
    	Int n = hash(key,nNodes);
	NodeInt node = nth(nodes,n);
	return node;
    }

    Maybe<Data> getData(Key key){
	NodeInt node;
	node = this.lookupNode(key);
	Fut<Maybe<Data>> f;
	f = node!getData(key);
	await f?;
	Maybe<Data> d = f.get;
	return d;
    }

    List<Maybe<Data>> getAllData(List<Key> keys){
	List<Maybe<Data>> r = Nil;
	Key firstK = 0; List<Key> tailKs = Nil;
	NodeInt node;
	Fut<Maybe<Data>> fd; Fut<List<Maybe<Data>>> fds; 
	Maybe<Data> d = Just(0); List<Maybe<Data>> ds = Nil;
	if (keys != Nil){
	    firstK = head(keys);
	    tailKs = tail(keys);
	    node = this.lookupNode(firstK);
	    fd = node!getData(firstK);
	    fds = this!getAllData(tailKs);
	    await fd? & fds?;
	    d = fd.get;
	    ds = fds.get;
	    r = Cons(d,ds);
	}
	return r;
    }

    [nodes <= max(nodes)]
    Set<Key> getAllKeys(){
	return this.getAllKeysAux(nodes);
    }
    
    Set<Key> getAllKeysAux(List<NodeInt> ns){
	Set<Key> r = EmptySet;
	NodeInt firstNode; List<NodeInt> tailNs = Nil;
	Fut<Set<Key>> fFirstKs; Fut<Set<Key>> fRKs; 
	Set<Key> firstKs = EmptySet; Set<Key> rKs = EmptySet;
	if (ns != Nil){
	    firstNode = head(ns);
	    tailNs = tail(ns);
	    fFirstKs = firstNode!getKeys();
	    fRKs = this!getAllKeysAux(tailNs);
	    await fFirstKs? & fRKs?;
	    firstKs = fFirstKs.get;
	    rKs = fRKs.get;
	    r = union(firstKs,rKs);
	}
	return r;
    }

    Unit putData(Key key,Data d){
	NodeInt node;
	node = this.lookupNode(key);
	node!putData(key,d);
    }
}


class Node(Map<Key,Data> map) implements NodeInt{

    [map <= max(map)]
    Maybe<Data> getData(Key key){
	return lookup(map,key);
    }

    [map <= max(map)]
    Unit putData(Key key,Data d){
	map = myput(map,key,d);
    }

    [map <= max(map)]
    Set<Key> getKeys(){
	return keys(map);
    }
}

interface IMain {
    Unit main(List<NodeInt> nodes,Int nNodes, Int nData);
}

class Main () implements IMain {
    Unit main(List<NodeInt> nodes,Int nNodes, Int nData) {
	Map<Key,Data> m1 = EmptyMap;
	Map<Key,Data> m2 = EmptyMap;
	NodeInt n1 = new Node(m1);
	NodeInt n2 = new Node(m2);
	DistHTInt dht = new DistHT(Cons(n1,Cons(n2,Nil)),nNodes);
	dht!putData(nData,nData);
	while(nData > 0) {
	    dht!putData(nData,nData);
	    nData = nData - 1;
	}	
	dht!getAllData(Cons(2,Nil));
    	dht!getAllData(Cons(2,Cons(5,Cons(4,Nil))));
    }
}

interface IC {
    Unit m2(List<NodeInt> nodes,Int nNodes, Int nData);
    Unit m3(List<NodeInt> nodes,Int nNodes, Int nData);
}

class C implements IC{
    
    Unit m(List<NodeInt> nodes,Int nNodes, Int nData) {
	IC main1 = new local C();
	IC main2 = new local C();
	
	main1!m2(nodes,nNodes, nData);
	main2!m2(nodes,nNodes, nData);
    }
    
    Unit m2(List<NodeInt> nodes,Int nNodes, Int nData) {
	IC main1 = new C ();
	IC main2 = new C ();
	
	main1!m3(nodes,nNodes, nData);
	main2!m3(nodes,nNodes, nData);
    }
    
    Unit m3(List<NodeInt> nodes,Int nNodes, Int nData) {
	IMain main1 = new Main ();
	IMain main2 = new Main ();
	
	main1!main(nodes,nNodes, nData);
	main2!main(nodes,nNodes, nData);
    }
}
