(GOAL COMPLEXITY)
(STARTTERM (FUNCTIONSYMBOLS f0))
(VAR x y z)
(RULES

# t1
f0(x, y, z) -> f1(x, y, z)

# t2
f1(x, y, z) -> f3(x, y, z)      :|: x < 0
#t8
# f1(x, y, z) -> f3(x, y, z)      :|: x = 0 && y <= 0

# t3
f1(x, y, z) -> f1(x-1, x, z)    :|: x > 0 && y <= 0
# t5
f1(x, y, z) -> f2(x, y, x+1)    :|: x >= 0 && y > 0
# t6
f2(x, y, z) -> f1(x, y, z)      :|: y <= 0
# t7
f2(x, y, z) -> f2(x, y+x-z, z)  :|: y > 0

)

# LoAT antiguo: OMEGA(1)
# No puede acelerar t7 porque no sabe que y decrecerá de 1 en 1:
#       Accelerating the following rules:
#          5: f2 -> f2 : y'=-z+x+y, [ y>0 ], cost: 1
#       Found no metering function for rule 5.

# LoAT nuevo: OMEGA(n)
# Es más listo y acelera f2 -> f2 usando un invariante, pero este no es lo suficiente potente como 
# para saber que f2 -> f2 se ejecuta exactamente 'y' veces
#    Accelerating the following rules:
#      5: f2 -> f2 : y'=-z+x+y, [ y>0 ], cost: 1
#    [test] deduced invariant 1-z+x<=0

# Es un ejemplo de bucle anidado t3 externo decreciendo x, luego el SCC de t5 es un bucle
# interno decreciendo y 
# Posiblemente se pueda comprimir en un único nodo, como dice Albert

# Se obtiene la MF(x,y,z) = <x,y> lexicográfica
# T  = {t3, t5, t6, t7}
# T1 = {t3, t6}
# T2 = {t5, t7}
# Para T1 la MF(x,y,z) = x sin ningún invariante, solo usando \not guard(T2) = y <= 0
# Para T2 la MF(x,y,z) = x pero necesita los invariantes locales
#  I_f1 = x >= 0
#  I_f2 = x >= 0 /\ z = x+1  [realmente la parte de x>=0 no se usa]


