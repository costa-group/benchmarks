# Primer ejemplo del punto 3.1 de las notas
# LoAT obtiene \Omega(n^1)

(GOAL COMPLEXITY)
(STARTTERM (FUNCTIONSYMBOLS f0))
(VAR x)
(RULES

# \tau_1: Te puedes quedar aqui bloqueado
f0(x) -> f1(x-1)  :|: x > 0  

# \tau_4, es lo mismo que no ponerla (LoAT la eliminar por "leaf rule")
f1(x) -> fin(x)   :|: x > 0
# \tau _2
f1(x) -> f2(x-1)  :|: x > 0  
f1(x) -> f0(x)

f2(x) -> f1(x)
# \tau_3
f2(x) -> f2(x-1)  :|: x > 0  

)

# Pasos de la solución por LoAT
# 1) eliminacion de \tau_4
# 2) aceleracion de \tau_3, generando
#      f2 -> f2 : x'=0, [ x>=0 ], cost: x
# 3) encadena \tau_2 con la regla acelerada, generando
#      f1 -> f2 : x'=0, [ x>0 ], cost: x
# 4) usar la regla f2 -> f1 sin cambios ni guardas para concatenarlas en todas
#    las reglas que terminan en f2, generando bucles
#      f1 -> f1 : x'=-1+x, [ x>0 ], cost: 2
#      f1 -> f1 : x'=0, [ x>0 ], cost: 1+x
# 5) Acelera el primer loop generado en 4), y produce una regla
#      f1 -> f1 : x'=0, [ x>=0 ], cost: 2*x
# 6) Encadena f1->f1 con las reglas que acaban en f1
#      f0 -> f1 : x'=0, [ -1+x>0 ], cost: 1+x
#      f0 -> f1 : x'=0, [ x>0 ], cost: -1+2*x
# 7) Usa la regla f1->f0 sin guardas para concatenarla en las reglas que 
#    terminan en f1
#       f0 -> f0 : x'=-1+x, [ x>0 ], cost: 2
#       f0 -> f0 : x'=0, [ -1+x>0 ], cost: 2+x
#       f0 -> f0 : x'=0, [ x>0 ], cost: 2*x
# 8) A partir de aqui acelera el primer bucle de 7), pero esto genera otra
#    regla f0->f0 con coste 2*x
# 9) Resuelve el problema límite de cada regla, que da \Omega(n^1) en cualquiera
#    de las reglas

